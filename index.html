<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>Formula 1 Driver Analyzer</title>
        <script type="text/javascript" src="d3.js" charset="utf-8"></script>
        <link rel="stylesheet" type="text/css" href="style.css"/>
	</head>
    
    <body>
    <script charset="utf-8"> 
    class Driver {
        surname;
        name;
        concatName;

        constructor(surname, name) {
            this.surname = surname;
            this.name = name;
            this.concatName = surname + " " + name;
        }
    }
    
    // Global variables
    var container_dimensions = {width: 550, height: 250}; // width: 650
    var margins = {top: 20, right: 20, bottom: 40, left: 45};
    var chart_dimensions = {
            width: container_dimensions.width - margins.left - margins.right,
            height: container_dimensions.height - margins.top - margins.bottom
    };
    var barSize = 30;
    var legend_width = 130;
    
    var wrapper;
    var barSvg; // Svg for the points bars
    var svgLegend;
    
    var showActiveDrivers = true; // Flag that indicates to show only active drivers
    var showTotalPoints = true; // Flag that indicates to show only active drivers
    var activeDrivers = []; // List of drivers loaded by the data that are active
    var retiredDrivers = []; // List of drivers loaded by the data that are retired
    
    function contains(drivers, driver) {
        for (i = 0; i < drivers.length; i++) {
            currentDriver = drivers[i];
            if (drivers[i].name == driver.name && drivers[i].surname == driver.surname) {
                return i+1; 
            }
        }
        return 0;
    }
    
    // Draws the title screen above the charts
    function drawTitle() {
        // Creates the wrapper div that contains the div 'title'
        aboveWrapper = document.createElement('div');
        aboveWrapper.id = "abovewrapper";
        document.body.appendChild(aboveWrapper);
        
        // Creates the div 'title' which contains text, selections and buttons
        title = document.createElement('div');
        title.id = "title";
        title.innerHTML = "<h1>Formula 1 Driver Analyzer</h1>";
        aboveWrapper.appendChild(title);   
        
        // Creates the div 'menu' which allows the user to select a driver
        menu = document.createElement('div');
        menu.id = "menu";
        aboveWrapper.appendChild(menu);
        
        // Adds radios button in order to distinguish between active and retired drivers
        menu.innerHTML += "Choose between drivers that are: ";
        activeButton = document.createElement('input');
        activeButton.type = 'radio';
        activeButton.name = 'drivers';
        activeButton.id = 'active-drivers';
        activeButton.value = "active";
        label = document.createElement('label');
        label.innerHTML = "Active";
        menu.appendChild(activeButton);
        menu.appendChild(label);
        menu.innerHTML += "   ";
        
        retiredButton = document.createElement('input');
        retiredButton.type = 'radio';
        retiredButton.name = 'drivers';
        retiredButton.id = 'retired-drivers';
        retiredButton.value = "retired";
        label = document.createElement('label');
        label.innerHTML = "Retired";
        menu.appendChild(retiredButton);
        menu.appendChild(label);
        menu.innerHTML += "<br>";
        
        // Creates a selection for the drivers with a default option, and adds it to 'title'
        menu.innerHTML += "Please select a driver: ";

        selectDriver = document.createElement('select');
        selectDriver.id = "select-driver";
        selectDriver.style.width = "150px";
        defaultDriverOption = document.createElement('option');
        defaultDriverOption.value = 0;
        defaultDriverOption.innerHTML = "- DRIVER -";
        selectDriver.appendChild(defaultDriverOption);
        menu.appendChild(selectDriver);
        menu.innerHTML += "<br>";
        
         // Creates the search button, makes it disabled and adds it to 'title'
        searchButton = document.createElement('button');
        searchButton.id = "search";
        searchButton.innerHTML = "Search data!";
        searchButton.disabled = true;
        menu.appendChild(searchButton);
        
        about = document.createElement('div');
        about.id = "menu";
        aboveWrapper.appendChild(about);
        
        document.getElementById("active-drivers").checked = true; 
        loadData();
    }
    
    // Loads the data from the csv file
    function loadData() {
        d3.csv("results.csv", function(error, data) {
            // Prints the error in case something goes wrong
            if (error) {
                console.log(error);
            }
            // Everything goes ok!
            else {
                activeDrivers = []; // Will Contain all active drivers inside the csv file
                retiredDrivers = []; // Will contain all retired drivers inside the csv file
                data.forEach(function(d) { // Cycles through the data
                    d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                    d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                    driver = new Driver(d.surname, d.name);
                    if (d.year == 2019 && !contains(activeDrivers, driver)) {
                        activeDrivers.push(driver);
                        index = contains(retiredDrivers, driver);
                        if (index) {
                            retiredDrivers.splice(index-1, 1);
                        }
                    }
                    else if (!contains(retiredDrivers, driver) && !contains(activeDrivers, driver)) {
                        retiredDrivers.push(driver);
                    }
                });
                activeDrivers.sort(function(a, b){
                    if(a.surname < b.surname) { return -1; }
                    if(a.surname > b.surname) { return 1; }
                    return 0;
                });
                retiredDrivers.sort(function(a, b){
                    if(a.surname < b.surname) { return -1; }
                    if(a.surname > b.surname) { return 1; }
                    return 0;
                });
                
                addDriversToTitle(); // Adds the events to the user's selections in the title now that the data is loaded
                enableInputsToTitle(data);
            }
        });
    }
    
    // Adds the correct list of drivers to the selection
    function addDriversToTitle() {
        if (showActiveDrivers) {
            for (i = 0; i < activeDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = activeDrivers[i].concatName;
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
        else {
            for (i = 0; i < retiredDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = retiredDrivers[i].concatName;
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
    }
    
    // Adds events to the interactions of the user with the title screen
    function enableInputsToTitle(data) {
        document.getElementById("active-drivers").onclick = function() {
            showActiveDrivers = true;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("retired-drivers").onclick = function() {
            showActiveDrivers = false;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("select-driver").onchange = function() { 
            if (document.getElementById("select-driver").value > 0) {  // A valid driver is selected: enables search button
                document.getElementById("search").disabled = false;
            }
            else { // Default option selected: disables search button
                document.getElementById("search").disabled = true;
            }
        }
        search.onclick = function() { // Checks if the user clicks the search button
            value = document.getElementById("select-driver").value;
            if (showActiveDrivers) {
                surname = activeDrivers[value-1].surname;
                name = activeDrivers[value-1].name;
                initializeChartsLayout(data, surname, name);
            }
            else {
                surname = retiredDrivers[value-1].surname;
                name = retiredDrivers[value-1].name;
                initializeChartsLayout(data, surname, name);
            }
        }    
    }
    
    // Prepares the layouts of the charts before plotting data on them
    function initializeChartsLayout(data, surname, name) {
        // Removes the previous layout and restores global variables
        if (document.body.contains(wrapper)) {
            wrapper.remove();
        }
        showTotalPoints = true;
        
        // Initializes the middle wrapper
        wrapper = document.createElement('div');
        wrapper.id = "middlewrapper";
        wrapper.innerHTML += "<br>";
        document.body.append(wrapper);
        
        // Prepares all the layouts
        preparePointsAchieved(data, surname, name);    
        prepareComparisons(data, surname, name);
    }
    
    // Prepares the layout for the points achieved chart
    function preparePointsAchieved(data, surname, name) {
        // Initializes the div that contains the svg area for the points bars    
        svgDiv = document.createElement('div');
        svgDiv.id = "bargraph";
        svgDiv.innerHTML = "Points Per Season<br>";
        wrapper.append(svgDiv); 
        
        // Initalizes an empty svg for the points bars
        barSvg = d3.select('#bargraph')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Adds radios button in order to switch between total points and average points per race
        optionsDiv = document.createElement('div');
        svgDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        totalButton = document.createElement('input');
        totalButton.type = 'radio';
        totalButton.name = 'points';
        totalButton.id = 'total-points';
        totalButton.value = "total";
        label = document.createElement('label');
        label.innerHTML = "Total Points";
        optionsDiv.appendChild(totalButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";

        averageButton = document.createElement('input');
        averageButton.type = 'radio';
        averageButton.name = 'points';
        averageButton.id = 'average-points';
        averageButton.value = "average";
        label = document.createElement('label');
        label.innerHTML = "Average Points Per Race";
        optionsDiv.appendChild(averageButton);
        optionsDiv.appendChild(label);
        document.getElementById("total-points").checked = true;
        
        document.getElementById('total-points').onclick = function() {
            showTotalPoints = true;
            plotPointsAchieved(data, surname, name);
        }
        document.getElementById('average-points').onclick = function() {
            showTotalPoints = false;
            plotPointsAchieved(data, surname, name);
        }
      
        // Initializes the div for the points bar graph legend
        svgLegendDiv = document.createElement('div');
        svgLegendDiv.innerHTML = "Legend Table<br>";
        svgLegendDiv.id = "legendtable";
        wrapper.append(svgLegendDiv);
        
        // Initializes the empty svg for the bar graph legend
        svgLegend = d3.select('#legendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","legendtable");
        
        // Plots the bar graph that shows the points achieved by the driver season by season
        plotPointsAchieved(data, surname, name);
    }
          
    // Plot a bar graph that shows the points achieved by the driver season by season
    function plotPointsAchieved(data, surname, name) {
        // Erase previous data
        barSvg.selectAll('*').remove();
    
        // Finds the relevant data to plot
        relevantData = findPointsAchieved(data, surname, name);
  
        // Initializes the x scale
        minYear = relevantData[0].key;
        maxYear = relevantData[relevantData.length-1].key;
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key;
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        // Initializes the y scale
        maxPoints = 0;
        for (i = 0; i < relevantData.length; i++) {
            points = 0;
            for (j = 0; j < relevantData[i].values.length; j++) {
                points += relevantData[i].values[j].value.totalPoints;
            }
            if (points > maxPoints) {
                maxPoints = points;
            }
        }
        if (maxPoints == 0) {
            maxPoints = 1;
        }
        y = d3.scaleLinear()
            .domain([maxPoints, 0])
            .range([0, chart_dimensions.height]);
        
        // Initializes the colors
        colors = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yAxis = d3.axisLeft(y).ticks().tickFormat(d3.format("d"));
        
        // Appends the x axis
        barSvg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+(chart_dimensions.height)+")")
            .call(xAxis);
        barSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the y axis
        barSvg.append("g")
            .attr("class","y_axis")
            .call(yAxis)
        barSvg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.2em")
            .style("text-anchor","end")
            .text(function() {
                if (showTotalPoints) {
                    return "Total Points";
                }
                else {
                    return "Avg. Points Per Race";
                }
            });
       
        // Draws the bars
        constructors = []; // Keeps a list of constructors for the legend
        for (i = 0; i < relevantData.length; i++) { // Cycles through the years
            year = relevantData[i].key;
            for (j = 0; j < relevantData[i].values.length; j++) { // Cycles through the constructors per year
                constructor = relevantData[i].values[j].key;
                if (!constructors.includes(constructor) && relevantData[i].values[j].value.totalPoints > 0) { // Filters out constructors with zero points
                    constructors.push(constructor);
                } 
                if (j > 0) { // Check if there's a bar below (aka a constructor change in the season) and if so, it takes its measures
                    barBelowY = relevantData[i].values[j-1].value.totalPoints;
                }
                bar = barSvg.selectAll("bar")
                    .data([relevantData[i].values[j].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", constructor + year)
                        .style("fill", function(d) {
                            return colors(constructor);
                        })
                        .style("opacity", function(d) {
                            if (d.totalPoints == 0) {
                                return 0; }
                            else {
                                return 1;
                            }
                        })
                        .attr("stroke-width", 3)
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", y(0))
                        .attr("height", 0);
                        
                // Handles the animations
                drawInvisibleBar = true; // Flag that indicates to draw an invisible bar in case there are no points (so that labels can still appear)
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) { 
                        if (j > 0) { // If there's a bar below, stack the new bar above it
                            return y(d.totalPoints + barBelowY);
                        }
                        if (d.totalPoints == 0) { // Check if to draw an invisible bar
                            for (z = j; z < relevantData[i].values.length; z++) { // Checks if the driver got points with other constructors in that year
                                if (relevantData[i].values[z].value.totalPoints > 0) {
                                    drawInvisibleBar = false; // Can't draw a bar since there's will be a visible bar later for this year
                                }
                            }
                            if (drawInvisibleBar) {
                                return y(maxPoints);
                            }
                        }
                        return y(d.totalPoints); 
                    })
                    .attr("height", function(d) { 
                        if (j > 0) {
                            return y(barBelowY) - y(d.totalPoints+barBelowY);
                        }
                        if (d.totalPoints == 0 && drawInvisibleBar) { // Invisible bar
                            return chart_dimensions.height - y(maxPoints);
                        }
                        return chart_dimensions.height - y(d.totalPoints); 
                    })
                
                // Handles inputs                 
                bar.on("mouseover", function(d) {
                   d3.select(this)
                        .style("stroke", "black");
                    coords = d3.mouse(this);
                            
                    // Adds information about the points near the mouse location
                    g = barSvg.append("g") // Each text label will be inside a black outlined rect in g
                        .attr("class", "rect_label");
                    classLength = d3.select(this).attr("class").length;
                    constructor = d3.select(this).attr("class").substring(0, classLength-4);
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    text = "[Points: " + d.totalPoints.toFixed(2) + ", Constructor: " + constructor.replace(/_/g, ' ') + "]";
                    rect = g.append('rect')
                        .attr("width", text.length*7)
                        .attr("height", 20)
                        .attr("stroke", "black")
                        .style("fill", "white"); 
                            
                    // Checks if to place the information on the right or on the left of the mouse location
                    if (parseInt(year) <= (parseInt(minYear)+ parseInt(maxYear))/2) {
                        rect.attr("x", coords[0]+6)
                            .attr("y", coords[1]-30);
                        g.append('text')
                            .attr("x", coords[0]+10)
                            .attr("y", coords[1]-15)
                            .attr("fill", colors(constructor))
                            .text(text);
                        }
                        else {
                            rect.attr("x", coords[0]-200)
                                .attr("y", coords[1]-30);
                             g.append('text')
                                .attr("x", coords[0]-196)
                                .attr("y", coords[1]-15)
                                .attr("fill", colors(constructor))
                                .text(text);      
                        }              
                    })
                   
                bar.on("mouseout", function(d) {
                    d3.select(this)
                        .style("stroke", "none"); 
                                
                    // Removes information about the points near the mouse location
                    d3.select(".rect_label")
                        .remove();
                });
               
                
            }        
        }
        
        // Draws the legend for the graph
        plotPointsAchievedLegend(constructors);      
    }
        
    // Draws the legend for the points bar graph
    function plotPointsAchievedLegend(constructors) {
        // Erase previous data
        svgLegend.selectAll('*').remove();
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgLegend.selectAll("legend")
            .data(constructors)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*10)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colors(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
            
        /* Add input events to the legend
        legend
            .on("mouseover", function(d) {
                // Highlights the entry in the legend and outlines the right bars
                d3.select(".rect"+d)
                    .attr("stroke", "black");
                d3.select(".text"+d)
                    .attr("text-decoration", "underline overline");
                for (i = 1950; i <= 2019; i++) {
                    d3.select("." + d + i)
                        .attr("stroke", "black");                   
                } 
            })
            .on("mouseout", function(d) {
                // Restores everything
                d3.select(".rect"+d)
                    .attr("stroke", "none");
                d3.select(".text"+d)
                    .attr("text-decoration", "none");
                for (i = 1950; i <= 2019; i++) {
                    d3.select("." + d + i)
                        .attr("stroke", "none");
                } 
            }); */
    }
    
    // Prepares the layout for the comparisons with teammates chart
    function prepareComparisons(data, surname, name) {
        // Initializes the div that contains the svg area for the comparisons   
        svgCmpDiv = document.createElement('div');
        svgCmpDiv.id = "comparisons";
        svgCmpDiv.innerHTML = "Wins Against Teammates<br>";
        wrapper.append(svgCmpDiv); 
        
        // Initalizes an empty svg for the points bars
        cmpSvg = d3.select('#comparisons')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
    }
        
          
    // Finds the points achieved by a driver season by season
    function findPointsAchieved(data, surname, name) {
        // Groups all the results by pilot
        groupedResults = d3.nest()
            .key(function(d) {
                return d.surname + "_" + d.name;
            })
            .entries(data);

        // Finds the results of the selected pilot
        relevantResults = [];
        for (i = 0; i < groupedResults.length; i++) {
            driverResults = groupedResults[i];
            if (driverResults.key == surname + "_" + name) {
                relevantResults = driverResults.values;
            }
        }
        
        // Groups the relevant results by year/constructor and finds the total number of points by year/constructor
        if (showTotalPoints) {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.sum(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        // Groups the relevant results by year/constructor and finds the average number of points per race by year/constructor
        else {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.mean(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        
        console.log(relevantResults);   
        return relevantResults;
    }
        
                       
    drawTitle();
    </script>
    </body>
</html>