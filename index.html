<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>Formula 1 Driver Analyser</title>
        <script type="text/javascript" src="d3.js" charset="utf-8"></script>
        <script src="https://unpkg.com/d3-simple-slider"></script>
        <link rel="stylesheet" type="text/css" href="style.css"/>
	</head>
    
    <body>
    <script charset="utf-8">  
    // Dimensions
    var margins = {top: 20, right: 10, bottom: 40, left: 45};
    var container_dimensions = {width: 550, height: 250}; 
    var chart_dimensions = {
        width: container_dimensions.width - margins.left - margins.right,
        height: container_dimensions.height - margins.top - margins.bottom
    };
    var small_container_dimensions = {width: 450, height: 220};
    var small_chart_dimensions = {
        width: small_container_dimensions.width - margins.left - (margins.right + 30),
        height: small_container_dimensions.height - margins.top - margins.bottom
    };
    var barSize = 30;
    var legend_width = 119;
    var timeslider_height = 55;
    
    // Divs, elements and svgs
    var aboveWrapper, wrapper, bottomWrapper;
    var barSvg, svgLegend;
    var cmpSvg, svgCmpLegend;
    var dnfTimeSliderSvg, dnfSvg, labelTotalRacesDNF;
    var consTimeSliderSvg, consSvg, labelTotalRacesCons;
    
    // User inputs
    var showActiveDrivers = true; // Flag that indicates to show only active drivers
    var showTotalPoints = true; // Flag that indicates to show the total points instead of the average per race
    var showWinsInRaces = true; // Flag that indicates to show the wins in races instead of qualifying
    
    // Drivers data
    var activeDrivers = []; // List of drivers loaded by the data that are active
    var retiredDrivers = []; // List of drivers loaded by the data that are retired
    var selectedDriver = "";
    var minYear;
    var maxYear;
    
    // Avg line parameters
    var barsClicked = []; // List of bars clicked in the total points chart
    var nBarsClicked = 0;
    var cumulativePoints = 0;
    
    // Draws the title screen above the charts
    function drawTitle() {
        // Creates the wrapper div that contains the div 'title'
        aboveWrapper = document.createElement('div');
        aboveWrapper.id = "abovewrapper";
        aboveWrapper.onmouseover = function() {
            writeOnAbout(0);
        }
        document.body.appendChild(aboveWrapper);
        
        // Creates the div 'title' which contains text, selections and buttons
        var title = document.createElement('div');
        title.id = "title";
        title.innerHTML = "<h2>Formula 1 Driver Analyser</h2>";
        aboveWrapper.appendChild(title);   
        
        // Creates the div 'menu' which allows the user to select a driver
        var menu = document.createElement('div');
        menu.id = "menu";
        aboveWrapper.appendChild(menu);
        
        // Adds radios button in order to distinguish between active and retired drivers
        menu.innerHTML += "Choose between drivers that are: ";
        var activeButton = document.createElement('input');
        activeButton.type = 'radio';
        activeButton.name = 'drivers';
        activeButton.id = 'active-drivers';
        activeButton.value = "active";
        var label = document.createElement('label');
        label.innerHTML = "Active";
        menu.appendChild(activeButton);
        menu.appendChild(label);
        menu.innerHTML += "   ";
        
        var retiredButton = document.createElement('input');
        retiredButton.type = 'radio';
        retiredButton.name = 'drivers';
        retiredButton.id = 'retired-drivers';
        retiredButton.value = "retired";
        label = document.createElement('label');
        label.innerHTML = "Retired";
        menu.appendChild(retiredButton);
        menu.appendChild(label);
        menu.innerHTML += "<br>";
        
        // Creates a selection for the drivers with a default option, and adds it to 'title'
        menu.innerHTML += "Please select a driver: ";

        var selectDriver = document.createElement('select');
        selectDriver.id = "select-driver";
        selectDriver.style.width = "150px";
        var defaultDriverOption = document.createElement('option');
        defaultDriverOption.value = 0;
        defaultDriverOption.innerHTML = "- DRIVER -";
        selectDriver.appendChild(defaultDriverOption);
        menu.appendChild(selectDriver);
        menu.innerHTML += " ";
        
         // Creates the search button, makes it disabled and adds it to 'title'
        var searchButton = document.createElement('button');
        searchButton.id = "search";
        searchButton.innerHTML = "Search data!";
        searchButton.disabled = true;
        menu.appendChild(searchButton);
        
        var about = document.createElement('div');
        about.id = "about";
        aboveWrapper.appendChild(about);
        writeOnAbout(0);
        
        document.getElementById("active-drivers").checked = true; 
        loadData();
    }
    
    // Loads the data from the csv file
    function loadData() {
        d3.queue()
            .defer(d3.csv, "results.csv")
            .defer(d3.csv, "qualifying.csv")
            .defer(d3.csv, "driverStandings.csv")
            .await(function(error, data, data2) {
                // Prints the error in case something goes wrong
                if (error) {
                    console.log(error);
                }
                // Everything goes ok!
                else {
                    // Sort all the drivers in two list: one for the recent ones, the other for the past drivers
                    activeDrivers = []; // Will Contain all active drivers inside the csv file
                    retiredDrivers = []; // Will contain all retired drivers inside the csv file
                    data.forEach(function(d) { // Cycles through the data
                        d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                        d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                        var driver = d.surname + "_" + d.name;
                        if (d.year == 2020 && !activeDrivers.includes(driver)) {
                            activeDrivers.push(driver);
                            var index = retiredDrivers.indexOf(driver);
                            if (index) {
                                retiredDrivers.splice(index, 1);
                            }
                        }
                        else if (d.year >= 1996 && !retiredDrivers.includes(driver) && !activeDrivers.includes(driver)) {
                            retiredDrivers.push(driver);
                        }
                    });
                    
                    data2.forEach(function(d) { // Cycles through the qualifying data
                        d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                        d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                    });
                    
                    // Sort all drivers in alphabetical order
                    activeDrivers.sort(function(a, b) {
                        if (a < b) { 
                            return -1; 
                        }
                        if (a > b) { 
                            return 1; 
                        }
                        return 0;
                    });
                    retiredDrivers.sort(function(a, b){
                        if (a < b) { 
                            return -1; 
                        }
                        if (a > b) {
                            return 1; 
                        }
                        return 0;
                    });
                
                    addDriversToTitle(); // Adds the events to the user's selections in the title now that the data is loaded
                    enableInputsToTitle(data, data2);
                }
            });
    }
    
    // Adds the correct list of drivers to the selection
    function addDriversToTitle() {
        if (showActiveDrivers) {
            for (i = 0; i < activeDrivers.length; i++) {
                var newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = activeDrivers[i].replace(/_/g, ' ');
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
        else {
            for (i = 0; i < retiredDrivers.length; i++) {
                var newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = retiredDrivers[i].replace(/_/g, ' ');
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
    }
    
    // Adds events to the interactions of the user with the title screen
    function enableInputsToTitle(data, data2) {
        document.getElementById("active-drivers").onclick = function() {
            showActiveDrivers = true;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            var options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("retired-drivers").onclick = function() {
            showActiveDrivers = false;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            var options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("select-driver").onchange = function() { 
            if (document.getElementById("select-driver").value > 0) {  // A valid driver is selected: enables search button
                document.getElementById("search").disabled = false;
            }
            else { // Default option selected: disables search button
                document.getElementById("search").disabled = true;
            }
        }
        search.onclick = function() { // Checks if the user clicks the search button
            var value = document.getElementById("select-driver").value;
            if (showActiveDrivers) {
                selectedDriver = activeDrivers[value-1];
                initializeChartsLayout(data, data2);
            }
            else {
                selectedDriver = retiredDrivers[value-1];
                initializeChartsLayout(data, data2);
            }
        }    
    }
    
    // Prepares the layouts of the charts before plotting data on them
    function initializeChartsLayout(data, data2) {
        // Removes the previous layout and restores global variables
        if (document.body.contains(wrapper)) {
            wrapper.remove();
            bottomWrapper.remove();
            document.getElementById("selecteddriver").remove();
            document.getElementById("endingdiv").remove();
        }
        showTotalPoints = true;
        showWinsInRaces = true;
        
        // Appends the div with the name of the driver selected
        var driverSelectedDiv = document.createElement('div');
        driverSelectedDiv.id = "selecteddriver";
        driverSelectedDiv.innerHTML = "<b>- " + selectedDriver.replace(/_/g, ' ') + " -</b";
        document.body.appendChild(driverSelectedDiv);
        
        // Initializes the middle wrapper
        wrapper = document.createElement('div');
        wrapper.id = "middlewrapper";
        wrapper.innerHTML += "<br>";
        document.body.append(wrapper);
        
        // Prepares all the layouts in the middle wrapper
        preparePointsAchieved(data);    
        prepareComparisons(data, data2);
        
        // Initializes the bottom wrapper
        bottomWrapper = document.createElement('div');
        bottomWrapper.id = "bottomwrapper";
        bottomWrapper.innerHTML += "<br>";
        document.body.append(bottomWrapper);
        
        // Prepares all the layouts in the bottom wrapper
        prepareDNF(data);
        prepareConsistency(data);
        
        // Appends the yellow ending div
        var endingDiv = document.createElement('div');
        endingDiv.id = "endingdiv";
        endingDiv.innerHTML = "- All data taken from: ";
        var link = document.createElement('a');
        link.innerHTML = "https://www.kaggle.com/rohanrao/formula-1-world-championship-1950-2020";
        link.setAttribute('href', "https://www.kaggle.com/rohanrao/formula-1-world-championship-1950-2020");
        endingDiv.appendChild(link);
        endingDiv.innerHTML += " -";
        document.body.appendChild(endingDiv);
    }
    
    // Prepares the layout for the points achieved chart
    function preparePointsAchieved(data) { 
        // Initializes the div that contains the svg area for the points bars    
        var svgDiv = document.createElement('div');
        svgDiv.id = "bargraph";
        svgDiv.innerHTML = "<b>Points Per Season</b><br>";
        svgDiv.onmouseover = function() {
            writeOnAbout(1);
        }
        wrapper.append(svgDiv); 
        
        // Initalizes an empty svg for the points bars
        barSvg = d3.select('#bargraph')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Adds radios button in order to switch between total points and average points per race
        var optionsDiv = document.createElement('div');
        svgDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        var totalButton = document.createElement('input');
        totalButton.type = 'radio';
        totalButton.name = 'points';
        totalButton.id = 'total-points';
        totalButton.value = "total";
        var label = document.createElement('label');
        label.innerHTML = "Total Points";
        optionsDiv.appendChild(totalButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";

        var averageButton = document.createElement('input');
        averageButton.type = 'radio';
        averageButton.name = 'points';
        averageButton.id = 'average-points';
        averageButton.value = "average";
        label = document.createElement('label');
        label.innerHTML = "Average Points Per Race";
        optionsDiv.appendChild(averageButton);
        optionsDiv.appendChild(label);
        document.getElementById("total-points").checked = true;
        
        document.getElementById('total-points').onclick = function() {
            showTotalPoints = true;
            plotPointsAchieved(data);
        }
        document.getElementById('average-points').onclick = function() {
            showTotalPoints = false;
            plotPointsAchieved(data);
        }
      
        // Initializes the div for the points bar graph legend
        svgLegendDiv = document.createElement('div');
        svgLegendDiv.innerHTML = "Legend Table<br>";
        svgLegendDiv.id = "legendtable";
        svgLegendDiv.onmouseover = function() {
            writeOnAbout(1);
        }
        wrapper.append(svgLegendDiv);
        
        // Initializes the empty svg for the bar graph legend
        svgLegend = d3.select('#legendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","legendtable");
        
        // Plots the bar graph that shows the points achieved by the driver season by season
        plotPointsAchieved(data);
    }
          
    // Plot a bar graph that shows the points achieved by the driver season by season
    function plotPointsAchieved(data) {
        // Erase previous data
        barSvg.selectAll('*').remove();
        barsClicked = []; 
        nBarsClicked = 0;
        cumulativePoints = 0
    
        // Finds the relevant data to plot
        relevantData = findPointsAchieved(data);
  
        // Initializes the x scale
        minYear = relevantData[0].key;
        maxYear = relevantData[relevantData.length-1].key;
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key;
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        // Initializes the y scale
        maxPoints = 0;
        for (i = 0; i < relevantData.length; i++) {
            var points = 0;
            for (j = 0; j < relevantData[i].values.length; j++) {
                points += relevantData[i].values[j].value.totalPoints;
            }
            if (points > maxPoints) {
                maxPoints = points;
            }
        }
        if (maxPoints == 0) {
            maxPoints = 1;
        }
        y = d3.scaleLinear()
            .domain([maxPoints, 0])
            .range([0, chart_dimensions.height]);
        
        // Initializes the colors
        colors = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yAxis = d3.axisLeft(y).ticks().tickFormat(d3.format("d"));
        
        // Appends the x axis
        barSvg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+(chart_dimensions.height)+")")
            .call(xAxis);
        barSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the y axis
        barSvg.append("g")
            .attr("class","y_axis")
            .call(yAxis)
        barSvg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.2em")
            .style("text-anchor","end")
            .text(function() {
                if (showTotalPoints) {
                    return "Total Points";
                }
                else {
                    return "Avg. Points Per Race";
                }
            });
       
        // Draws the bars
        constructors = []; // Keeps a list of constructors for the legend
        for (i = 0; i < relevantData.length; i++) { // Cycles through the years
            year = relevantData[i].key;
            for (j = 0; j < relevantData[i].values.length; j++) { // Cycles through the constructors per year
                constructor = relevantData[i].values[j].key;
                
                // Behind the scenes stuff
                if (!constructors.includes(constructor) && relevantData[i].values[j].value.totalPoints > 0) { // Filters out constructors with zero points
                    constructors.push(constructor);
                } 
                if (j > 0) { // Check if there's a bar below (aka a constructor change in the season) and if so, it takes its measures
                    barBelowY = relevantData[i].values[j-1].value.totalPoints;
                }
                
                // Draws the bar
                bar = barSvg.selectAll("bar")
                    .data([relevantData[i].values[j].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", constructor + year)
                        .style("fill", function(d) {
                            return colors(constructor);
                        })
                        .style("opacity", function(d) {
                            if (d.totalPoints == 0) {
                                return 0; }
                            else {
                                return 1;
                            }
                        })
                        .attr("stroke-width", 3)
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", y(0))
                        .attr("height", 0);
                        
                // Handles the animations
                drawInvisibleBar = true; // Flag that indicates to draw an invisible bar in case there are no points (so that labels can still appear)
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) { 
                        if (j > 0) { // If there's a bar below, stack the new bar above it
                            return y(d.totalPoints + barBelowY);
                        }
                        if (d.totalPoints == 0) { // Check if to draw an invisible bar
                            for (z = j; z < relevantData[i].values.length; z++) { // Checks if the driver got points with other constructors in that year
                                if (relevantData[i].values[z].value.totalPoints > 0) {
                                    drawInvisibleBar = false; // Can't draw a bar since there's will be a visible bar later for this year
                                }
                            }
                            if (drawInvisibleBar) {
                                return y(maxPoints);
                            }
                        }
                        return y(d.totalPoints); 
                    })
                    .attr("height", function(d) { 
                        if (j > 0) {
                            return y(barBelowY) - y(d.totalPoints+barBelowY);
                        }
                        if (d.totalPoints == 0 && drawInvisibleBar) { // Invisible bar
                            return chart_dimensions.height - y(maxPoints);
                        }
                        return chart_dimensions.height - y(d.totalPoints); 
                    });
                
                // Handles inputs                 
                bar.on("mouseover", function(d) {  
                    if (nBarsClicked == 0) {
                        d3.select(this)
                            .style("stroke", "black");
                    }
                    // Draws a label with information about the bar
                    coords = d3.mouse(this);
                    classLength = d3.select(this).attr("class").length;
                    constructor = d3.select(this).attr("class").substring(0, classLength-4);
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    text = "[Points: " + d.totalPoints.toFixed(2) + ", Constructor: " + constructor.replace(/_/g, ' ') + "]";
                    drawOnMouseOverLabel(coords, barSvg, text, colors(constructor), year, minYear, maxYear);
                });
                   
                bar.on("mouseout", function(d) {      
                    if (nBarsClicked == 0) {
                        d3.select(this)
                            .style("stroke", "none");
                    }
                    // Removes the label with information about the bar
                    d3.select(".rect_label")
                        .remove();
                });
                
                bar.on("click", function(d) {
                    // Selects the bar clicked, and also the other bars in the same year
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    selection = d3.selectAll("[class$='" + year + "']");
                    
                    // Calculates the total number of points to add/remove to the average
                    points = selection.data();
                    totalPoints = 0;
                    for (i = 0; i < points.length; i++) {
                        totalPoints += points[i].totalPoints;
                    }
                    
                    // Gives them a stroke if they have been selected for the first time, otherwise removes the previous stroke
                    add = true; // Flag that indicates if to increase or decrease the total number of points across the season 
                    selection
                        .style("stroke", function(d) {
                            currentClass = d3.select(this).attr("class");
                            if (!barsClicked.includes(currentClass)) {
                                barsClicked.push(currentClass);
                                return "black";
                            }
                            else {
                                add = false;
                                index = barsClicked.indexOf(currentClass);
                                barsClicked.splice(index, 1);
                                return "none";
                            }
                        })
                        .style("opacity", function(d) {
                            if (d3.select(this).style("opacity") == 0) {
                                return 0.1;
                            }
                            else if (d3.select(this).style("opacity") == 0.1) {
                                return 0;
                            }
                       });
                    
                    // Calculates the total number of points to add/remove to the cumulative points across the seasons
                    points = selection.data();
                    if (add) {
                        nBarsClicked += 1;
                        for (i = 0; i < points.length; i++) {
                            cumulativePoints += points[i].totalPoints;
                        }
                    }
                    else {
                        nBarsClicked -= 1;
                        for (i = 0; i < points.length; i++) {
                            cumulativePoints -= points[i].totalPoints;
                        }
                    }
                    
                    /* DEBUG
                    console.log("[" + cumulativePoints + ", " + nBarsClicked + "]"); */
                    
                    // Adds/update a mean line in the total points bar chart
                    d3.select(".mean").remove()
                    
                    if (nBarsClicked > 0) {
                        mean = cumulativePoints/nBarsClicked;
                        barSvg.append("line")
                            .attr("class", "mean")
                            .attr("x1", 0)
                            .attr("y1", y(mean))
                            .attr("x2", chart_dimensions.width)
                            .attr("y2", y(mean))
                            .style("stroke", "red")
                            .style("stroke-width", 3)
                            .on("mouseover", function(d) {
                                coords = d3.mouse(this);
                                text = "[Mean: " + mean.toFixed(2) + ", Sum: " + cumulativePoints.toFixed(2) + "] ";
                                drawOnMouseOverLabel(coords, barSvg, text, "red", year, minYear, maxYear);
                            })
                            .on("mouseout", function(d) {
                                d3.select(".rect_label")
                                    .remove();
                            });
                    }
                });
            }        
        }
        
        // Draws the legend for the graph
        drawPointsAchievedLegend(constructors);      
    }
        
    // Draws the legend for the points bar graph
    function drawPointsAchievedLegend(constructors) {
        // Erase previous data
        svgLegend.selectAll('*').remove();
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgLegend.selectAll("legend")
            .data(constructors)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*10)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colors(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
            
        // Add input events to the legend
        legend
            .on("mouseover", function(d) {
                // Highlights the entry in the legend and outlines the right bars
                d3.select(".rect"+d)
                    .attr("stroke", "black");
                d3.select(".text"+d)
                    .attr("text-decoration", "underline overline");
                if (nBarsClicked == 0) {
                    barSvg.selectAll("[class*=" + d + "]")
                        .style("stroke", "black");        
                }
            })
            .on("mouseout", function(d) {
                // Restores everything
                d3.select(".rect"+d)
                    .attr("stroke", "none");
                d3.select(".text"+d)
                    .attr("text-decoration", "none");
                if (nBarsClicked == 0) {
                    barSvg.selectAll("[class*=" + d + "]")
                        .style("stroke", "none"); 
                }
            });
    }
    
    // Prepares the layout for the comparisons with teammates chart
    function prepareComparisons(data, data2) {
        // Initializes the div that contains the svg area for the comparisons   
        svgCmpDiv = document.createElement('div');
        svgCmpDiv.id = "comparisons";
        svgCmpDiv.innerHTML = "<b>Wins/Losses Against Teammates</b><br>";
        svgCmpDiv.onmouseover = function() {
            writeOnAbout(2);
        }
        wrapper.append(svgCmpDiv); 
        
        // Initalizes an empty svg for the points bars
        cmpSvg = d3.select('#comparisons')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Adds radios button in order to switch between total points and average points per race
        optionsDiv = document.createElement('div');
        svgCmpDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        winsRacesButton = document.createElement('input');
        winsRacesButton.type = 'radio';
        winsRacesButton.name = 'races-or-quali';
        winsRacesButton.id = 'show-races';
        winsRacesButton.value = "races";
        label = document.createElement('label');
        label.innerHTML = "Wins In Races";
        optionsDiv.appendChild(winsRacesButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";

        winsQualiButton = document.createElement('input');
        winsQualiButton.type = 'radio';
        winsQualiButton.name = 'races-or-quali';
        winsQualiButton.id = 'show-quali';
        winsQualiButton.value = "quali";
        label = document.createElement('label');
        label.innerHTML = "Wins In Qualifying";
        optionsDiv.appendChild(winsQualiButton);
        optionsDiv.appendChild(label);
        document.getElementById("show-races").checked = true;
        
         document.getElementById('show-races').onclick = function() {
            showWinsInRaces = true;
            plotComparisons(data, data2);
        }
        document.getElementById('show-quali').onclick = function() {
            showWinsInRaces = false;
            plotComparisons(data, data2);
        }
        
        // Initializes the div for the points bar graph legend
        svgCmpLegendDiv = document.createElement('div');
        svgCmpLegendDiv.innerHTML = "Legend Table<br>";
        svgCmpLegendDiv.id = "cmplegendtable";
        svgCmpLegendDiv.onmouseover = function() {
            writeOnAbout(2);
        }
        wrapper.append(svgCmpLegendDiv);
        
        // Initializes the empty svg for the bar graph legend
        svgCmpLegend = d3.select('#cmplegendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","cmplegendtable");
        
        // Plots a bar graph that shows the comparisons with teammates
        plotComparisons(data, data2);
    }
    
    // Plots a bar graph that shows the comparisons with teammates
    function plotComparisons(data, data2) {
        // Erase previous data
        cmpSvg.selectAll('*').remove();
        
        // Finds the relevant data to plot
        relevantData = [];
        if (showWinsInRaces) {
            relevantData = findWinsAgainstTeammates(data);
        }
        else {
            relevantData = findWinsAgainstTeammates(data2);
        }
        
        // Initializes the x scale and finds the range of seasons
        minYear = relevantData[0].key.substring(0, 4);
        maxYear = relevantData[relevantData.length-1].key.substring(0, 4);
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key.substring(0, 4);
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        // Initializes the y scale and finds the biggest number of wins/losses in order to set up the scale
        maxWins = 0;
        previousYear = 0;
        topWins = 0;
        bottomWins = 0;
        for (i = 0; i < relevantData.length; i++) { // Cycles through the years
            year = relevantData[i].key.substring(0, 4); // Gets current year
            if (year != previousYear) { // If it is a new year (meaning no new teammates in the same year) the number of wins is resetted.
                previousYear = year;
                topWins = 0;
                bottomWins = 0;
            }
            topWins += relevantData[i].value.selectedDriverWins;
            if (topWins > maxWins) {
                maxWins = topWins;
            }
            bottomWins += relevantData[i].value.teammateWins;
            if (bottomWins > maxWins) {
                maxWins = bottomWins;
            }
        }
        if (maxWins == 0) {
            maxWins = 1;
        }
        yTop = d3.scaleLinear()
            .domain([maxWins, 0])
            .range([0, chart_dimensions.height/2]);
        
        yBottom = d3.scaleLinear()
            .domain([0, maxWins])
            .range([0, chart_dimensions.height/2]);
        
        // Initializes the colors
        colorsTeammates = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yTopAxis = d3.axisLeft(yTop).ticks(4).tickFormat(d3.format("d"));
        yBottomAxis = d3.axisLeft(yBottom).ticks(4).tickFormat(d3.format("d"));
        
        // Appends the x axis
        cmpSvg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+ (chart_dimensions.height) +")")
            .call(xAxis);
        cmpSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the top y axis
        cmpSvg.append("g")
            .attr("class","yTop_axis")
            .call(yTopAxis)
        cmpSvg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.5em")
            .style("text-anchor","end")
            .style("font", "12px times")
            .text(function(d) {
                if (showWinsInRaces) {
                    return "Wins In Races";
                }
                else {
                    return "Wins In Qualy";
                }
            });
        
        // Appends the bottom y axis
        cmpSvg.append("g")
            .attr("transform", "translate(0," + (chart_dimensions.height)/2 + ")")
            .attr("class","yBottom_axis")
            .call(yBottomAxis); 
        cmpSvg.append("text")
            .attr("class","label")
            .attr("transform", "translate(0," + (chart_dimensions.height) + ")" + "rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.5em")
            .style("text-anchor","start")
            .style("font", "12px times")
            .text(function(d) {
                if (showWinsInRaces) {
                    return "Losses In Races";
                }
                else {
                    return "Losses In Qualy";
                }
            });
        
        // Plot the data
        teammates = []; // Contains the list of drivers involved in the comparison
        teammates.push(selectedDriver);
        previousYear = 0; // Previous year found while cycling through the data
        barBelowTopY = 0; // Size of the bar on the top Y if there's one below the current one
        barAboveBottomY = 0; // Size of the bar on the bottom Y if there's one above the current one
        for (i = 0; i < relevantData.length; i++) {
            year = relevantData[i].key.substring(0, 4);
            
            // Check if there are more teammates in the same year (aka if there are already bars in place)
            if (year != previousYear) {
                previousYear = year;
                barBelowTopY = 0;
                barAboveBottomY = 0;
            }
            else {
                barBelowTopY += relevantData[i-1].value.selectedDriverWins;
                barAboveBottomY += relevantData[i-1].value.teammateWins;
            }
            
            // Refresh the list of teammates
            teammate = relevantData[i].key.substring(5, relevantData[i].key.length);
            if (!teammates.includes(teammate) && relevantData[i].value.teammateWins > 0) {
                teammates.push(teammate);
            }
            
            // Plot selected driver and teammate
            for (j = 0; j < 2; j++) {           
                bar = cmpSvg.selectAll("bar")
                    .data([relevantData[i].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", function(d) {
                            if (j == 0) { // Index 0 means this is the selected driver
                                return "rect0" + relevantData[i].key;
                            }
                            else { // Index 1 means this is the teammate
                                return "rect1" + relevantData[i].key;
                            }
                        })
                        .style("fill", function(d) {
                            if (j == 0) {
                                return colorsTeammates(selectedDriver);
                            }
                            else {
                                return colorsTeammates(teammate);
                            }
                        })
                        .style("stroke", "white")
                        .style("stroke-width", 1)
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", yTop(0))
                        .attr("height", 0);
                
                // Handles animation
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) {
                        if (j == 0) {
                            return yTop(d.selectedDriverWins + barBelowTopY);
                        }
                        else {
                            return yTop(-barAboveBottomY);
                        }
                    })
                    .attr("height", function(d) {
                        if (j == 0) {
                            if (barBelowTopY == 0) {
                                return chart_dimensions.height/2 - yTop(d.selectedDriverWins);
                            }
                            else {
                                return yTop(barBelowTopY) - yTop(d.selectedDriverWins + barBelowTopY);
                            }
                        }
                        else {
                            return yBottom(d.teammateWins);
                       }
                    });
                    
              
                // Handles inputs
                bar.on("mouseover", function(d) {
                    // Outlines the bar
                    d3.select(this)
                        .style("stroke", "black");
                
                    // Draws a label with information about the bar
                    coords = d3.mouse(this);
                    id = d3.select(this).attr("class");
                    flagTop = id.substring(4, 5);
                    year = id.substring(5, 9);
                    teammate = id.substring(10, id.length);
                    text = "";
                    color = "";
                    if (flagTop == "0") {     
                        text = "[Wins against " + teammate.replace(/_/g, ' ') + ": " + d.selectedDriverWins + "] ";
                        color = colorsTeammates(selectedDriver);
                    }
                    else {
                        text = "[Losses against " + teammate.replace(/_/g, ' ') + ": " + d.teammateWins + "] ";
                        color = colorsTeammates(teammate);
                    }
                    drawOnMouseOverLabel(coords, cmpSvg, text, color, year, minYear, maxYear);
                });
                
                bar.on("mouseout", function(d) {
                    // Restores everything
                    d3.select(this)
                        .style("stroke", "white");
                    d3.select(".rect_label")
                        .remove();
                });             
            }
        }  

        // Draws the legend
        drawComparisonLegend(data, data2, teammates);
    }
    
    // Draws the legend for the comparison graph
    function drawComparisonLegend(data, data2, teammates) {
        // Erase previous data
        svgCmpLegend.selectAll('*').remove();
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgCmpLegend.selectAll("legend")
            .data(teammates)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*5)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colorsTeammates(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .style("font", "12px times")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
        
        // Add input events to the legend
        legend
            .on("mouseover", function(d) {
                // Highlights the entry in the legend and outlines the right bars
                if (activeDrivers.includes(d) || retiredDrivers.includes(d)) {
                    d3.select(".rect"+d)
                        .attr("stroke", "black");
                    d3.select(".text"+d)
                        .attr("text-decoration", "underline overline");    
                }
                if (d == selectedDriver) {
                    cmpSvg.selectAll("[class^=rect0]")
                        .style("stroke", "black");
                }
                else {
                    cmpSvg.selectAll("[class^=rect1][class$=" + d + "]")
                        .style("stroke", "black");
                }
            })
            .on("mouseout", function(d) {
                // Restores everything
                d3.select(".rect"+d)
                    .attr("stroke", "none");
                d3.select(".text"+d)
                    .attr("text-decoration", "none");
                cmpSvg.selectAll("[class^=rect]")
                    .style("stroke", "white")
            })
            .on("click", function(d) {
                if (activeDrivers.includes(d) || retiredDrivers.includes(d)) {
                    selectedDriver = d;
                    initializeChartsLayout(data, data2);
                }
            });
    }
    
    // Prepares the layout for the chart that displays the causes of DNFs
    function prepareDNF(data) {
        // Initializes the div that contains the time slider and svg area for the dnf 
        svgDNFDiv = document.createElement('div');
        svgDNFDiv.id = "dnf";
        svgDNFDiv.innerHTML = "<b>DNFs' Causes</b><br>";
        svgDNFDiv.onmouseover = function() {
            writeOnAbout(3);
        }
        bottomWrapper.append(svgDNFDiv); 
        
        // Initializes an empty svg for the time slider
        svgDNFTimeSliderDiv = document.createElement('div');
        svgDNFTimeSliderDiv.id = "dnftimeslider";
        svgDNFDiv.appendChild(svgDNFTimeSliderDiv);
        dnfTimeSliderSvg = d3.select('#dnftimeslider')
            .append('svg')
                .attr("width", small_container_dimensions.width)
                .attr("height", timeslider_height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + (margins.left) + "," + margins.top + ")")
                .attr("id", "dnftimeslider");
        
        // Initalizes an empty svg for the points bars
        dnfSvg = d3.select('#dnf')
            .append('svg')
                .attr("width", small_container_dimensions.width)
                .attr("height", small_container_dimensions.height - 20)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + (margins.left+20) + "," + margins.top + ")")
                .attr("id", "dnf");
        
        // Text under the lollipop graph
        var textDiv = document.createElement('div');
        svgDNFDiv.appendChild(textDiv);
        labelTotalRacesDNF = document.createElement('label');
        labelTotalRacesDNF.style.fontSize = "14px";
        labelTotalRacesDNF.innerHTML = "Number of finishes: ";
        textDiv.appendChild(labelTotalRacesDNF);
              
        // Plots the timeslider and lollipop graph that displays data about the causes of DNFs
        drawDNFTimeSlider(data);
        plotDNF(data, minYear, maxYear);
    }
    
    // Draws a time slider for the DNF lollipop chart
    function drawDNFTimeSlider(data) {
        // Creates and adds the time slider
        var sliderDNF = d3.sliderBottom()
            .min(minYear)
            .max(maxYear)
            .width(small_chart_dimensions.width)
            .tickFormat(d3.format('d'))
            .ticks(5)
            .default([minYear, maxYear])
            .step(1)
            .fill('#2196f3')
            .on('onchange', val => {
                if (val[0] > val[1]) {
                    var swap = val[1];
                    val[1] = val[0];
                    val[0] = swap;
                }
                plotDNF(data, val[0], val[1]);
            });
        dnfTimeSliderSvg.call(sliderDNF); 
    }
        
    // Plots the lollipop graph that displays data about the causes of DNFs
    function plotDNF(data, selectedMinYear, selectedMaxYear) {
        // Erase previous data
        dnfSvg.selectAll('*').remove();
        
        // Finds the relevant data to plot and sorts it
        relevantData = findDNFs(data, selectedMinYear, selectedMaxYear);
        sortedRelevantData = relevantData.slice(2, relevantData.length);
        sortedRelevantData.sort(function(x, y) {
            return d3.descending(x.value, y.value);
        });
        
        // Initializes the x scale
        maxValue = 0;
        for (i = 0; i < sortedRelevantData.length; i++) {
            if (sortedRelevantData[i].value > maxValue) {
                maxValue = sortedRelevantData[i].value;
            }
        }
        if (maxValue == 0) {
            maxValue = 1;
        }
        xDNF = d3.scaleLinear()
            .domain([0, maxValue])
            .range([0, small_chart_dimensions.width])

        // Initializes the y scale;
        yDNF = d3.scaleBand()
            .domain(sortedRelevantData.map(function(d) {
                return d.key;
             }))
            .range([0, small_chart_dimensions.height])
            .padding(1);
        
        // Initializes the axis
        xAxis = d3.axisBottom(xDNF).ticks().tickFormat(d3.format("d"));
        yAxis = d3.axisLeft(yDNF).ticks();
        
        // Appends the x axis
        dnfSvg.append("g")
            .attr("class","xDNF_axis")
            .attr("transform", "translate(0,"+(small_chart_dimensions.height)+")")
            .call(xAxis);
        
        // Appends the y axis
        dnfSvg.append("g")
            .attr("class","yDNF_axis")
            .call(yAxis)
        
        sortedRelevantResults = relevantData.slice(2, relevantData.length);
        sortedRelevantResults.sort(function(x, y) {
            return d3.descending(x.value, y.value);
        });
        
        // Plot the lines
        lines = dnfSvg.selectAll("myline")
            .data(sortedRelevantData)
            .enter()
            .append("line")
                .attr("x1", xDNF(0))
                .attr("x2", xDNF(0))
                .attr("y1", function(d) { 
                    return yDNF(d.key); 
                })
                .attr("y2", function(d) { 
                    return yDNF(d.key); 
                })
                .style("stroke", "black")
                .style("stroke-width", 2);
        
        // Plot the circles
        circles = dnfSvg.selectAll("mycircle")
            .data(sortedRelevantData)
            .enter()
            .append("circle")
                .attr("cx", function(d) { 
                    return xDNF(d.value); 
                })
                .attr("cy", function(d) { 
                    return yDNF(d.key); 
                })
                .attr("r", "4")
                .style("fill", "#69b3a2")
                .style("opacity", 0)
                .style("stroke", "black") 
        
        // Handles the animations
        lines.transition()
            .duration(2000)
            .attr("x1", function(d) { 
                    return xDNF(d.value);
                });   
        circles.transition()
            .duration(2000)
            .delay(1500)
            .style("opacity", 1);
        
        // Handles the inputs
        circles.on("mouseover", function(d) {
            d3.select(this).attr("r", "6");
            coords = d3.mouse(this);
            ratio = ((d.value)*100)/relevantData[0].value;
            text = "[" + d.key.substring(0, 3).toUpperCase() + ": " + d.value + " (" + ratio.toFixed(2) + "% of the races)] ";
            drawOnMouseOverLabel(coords, dnfSvg, text, "black", d.value, 0, maxValue);
        });
        circles.on("mouseout", function(d) {
            d3.select(this).attr("r", "4");
            d3.select(".rect_label")
                .remove();
        });
        
        // Adds the stats under the graph
        finishesRatio = (relevantData[1].value*100)/relevantData[0].value;
        labelTotalRacesDNF.innerHTML = "Number of finishes: " + relevantData[1].value + " (" + finishesRatio.toFixed(2) + "% of the races)<br>";
        sumDNF = sortedRelevantData[0].value + sortedRelevantData[1].value + sortedRelevantData[2].value;
        dnfRatio = (sumDNF*100)/relevantData[0].value;
        labelTotalRacesDNF.innerHTML += "Number of DNFs: " +  sumDNF + " (" + dnfRatio.toFixed(2) + "% of the races)";
    }
    
    // Prepares the layout for the chart that displays the consistency of the placements
    function prepareConsistency(data) {
        // Initializes the div that contains the time slider and svg area for the placements
        svgConsDiv = document.createElement('div');
        svgConsDiv.id = "consistency";
        svgConsDiv.innerHTML = "<b>Placements' Consistency On Finishes</b><br>";
        svgConsDiv.onmouseover = function() {
            writeOnAbout(4);
        }
        bottomWrapper.append(svgConsDiv); 
        
        // Initializes an empty svg for the time slider
        svgConsTimeSliderDiv = document.createElement('div');
        svgConsTimeSliderDiv.id = "constimeslider";
        svgConsDiv.appendChild(svgConsTimeSliderDiv);
        consTimeSliderSvg = d3.select('#constimeslider')
            .append('svg')
                .attr("width", small_container_dimensions.width)
                .attr("height", timeslider_height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + (margins.left) + "," + margins.top + ")")
                .attr("id", "constimeslider");
        
        svgConsDiv2 = document.createElement('div');
        svgConsDiv.appendChild(svgConsDiv2);
        svgConsDiv2.appendChild(document.createTextNode("Show placements from: "));
        var selectTrack = document.createElement('select');
        selectTrack.id = "select-track";
        selectTrack.style.width = "150px";
        var defaultTrackOption = document.createElement('option');
        defaultTrackOption.value = 0;
        defaultTrackOption.innerHTML = "- EVERY TRACK -";
        selectTrack.appendChild(defaultTrackOption);
        svgConsDiv2.appendChild(selectTrack);
        
        // Initalizes an empty svg for box plot
        consSvg = d3.select('#consistency')
            .append('svg')
                .attr("width", small_container_dimensions.width)
                .attr("height", (small_container_dimensions.height/2)+40)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + (margins.left) + "," + margins.top + ")")
                .attr("id", "cons");
        
        // Text under the boxplot graph
        var textDiv = document.createElement('div');
        svgConsDiv.appendChild(textDiv);
        labelTotalRacesCons = document.createElement('label');
        labelTotalRacesCons.style.fontSize = "14px";
        labelTotalRacesCons.innerHTML = "Number of finishes: ";
        textDiv.appendChild(labelTotalRacesCons);
 
        // Draws the time slider and the boxplot
        drawConsistencyTimeSlider(data);
        plotConsistency(data, minYear, maxYear);
    }
    
    // Draws a time slider fot the consistency plot box
    function drawConsistencyTimeSlider(data) {
        // Creates and adds the time slider
       var sliderConsistency = d3.sliderBottom()
            .min(minYear)
            .max(maxYear)
            .width(small_chart_dimensions.width)
            .tickFormat(d3.format('d'))
            .ticks(5)
            .default([minYear, maxYear])
            .step(1)
            .fill('#2196f3')
            .on('onchange', val => {
                if (val[0] > val[1]) {
                    var swap = val[1];
                    val[1] = val[0];
                    val[0] = swap;
                }
                plotConsistency(data, val[0], val[1]);
            });
        consTimeSliderSvg.call(sliderConsistency); 
    }
    
    // Plots the plot box with the placements of the driver
    function plotConsistency(data, selectedMinYear, selectedMaxYear) {
        // Erase previous data
        consSvg.selectAll('*').remove();
        
        // Finds the relevant data to plot and sorts it
        var relevantData = findPlacements(data, selectedMinYear, selectedMaxYear);
        
        // Initializes the x scale
        xCons = d3.scaleLinear()
            .domain([1, 22])
            .range([0, small_chart_dimensions.width])
            
        // Initializes the axis
        xAxis = d3.axisBottom(xCons).ticks(22).tickFormat(d3.format("d"));
        
        // Appends the x axis
        consSvg.append("g")
            .attr("class","xCons_axis")
            .attr("transform", "translate(0,"+((small_chart_dimensions.height/2)+10)+")")
            .call(xAxis);
        consSvg.append("text")
            .attr("class","label")
            .attr("x", small_chart_dimensions.width)
            .attr("y", ((small_chart_dimensions.height/2)+10)+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Placements");
        
        // Finds the right values for the boxplot
        sortedRelevantResults = relevantData.sort(function(x, y) {
            return d3.ascending(x, y);
        });
        var q1 = d3.quantile(sortedRelevantResults, .25);
        var median = d3.quantile(sortedRelevantResults, .5);
        var q3 = d3.quantile(sortedRelevantResults, .75);
        var interQuantileRange = q3 - q1;
    
       
        var min = Math.round(q1 - 1.5 * interQuantileRange);
        if (min < sortedRelevantResults[0]) {
            min = sortedRelevantResults[0];
        }
        var max = Math.round(q1 + 1.5 * interQuantileRange);
        var boxHeight = 25;
        var yCenter = 50;
        
        // DEBUG
        console.log(sortedRelevantResults);
        console.log("q1: " + q1 +", median: " + median +", q3: " + q3 + ", Interquantile Range: " + interQuantileRange);
        console.log("Min: " + min + ", Max: " + max); 

        // Draws the main horizontal line
        consSvg.append("line")
            .attr("x1", xCons(min))
            .attr("x2", xCons(min))
            .attr("y1", yCenter)
            .attr("y2", yCenter)
            .attr("stroke", "black")
            .style("opacity", 0)
            .transition()
                .duration(2000)
                .attr("x2", xCons(max))
                .style("opacity", 1);

        // Draws the box
        consSvg.append("rect")
            .attr("x", xCons(q1))
            .attr("y", yCenter - boxHeight/2)
            .attr("height", boxHeight)
            .attr("width", (xCons(q3)-xCons(q1)))
            .attr("stroke", "black")
            .style("fill", "#69b3a2")
            .style("opacity", 0)
            .transition()
                .duration(2000)
                .delay(1500)
                .style("opacity", 1);

        // Draws median, min and max vertical lines
        consSvg.selectAll("toto")
            .data([min, median, max])
            .enter()
            .append("line")
                .attr("x1", function(d) {
                    return xCons(d);
                })
                .attr("x2", function(d) {
                    return xCons(d);
                })
                .attr("y1", yCenter + boxHeight/2)
                .attr("y2", yCenter - boxHeight/2)
                .attr("stroke", "black")
                .style("opacity", 0)
                .transition()
                    .duration(2000)
                    .delay(1500)
                    .style("opacity", 1);
                
        // Refreshes the counter
        labelTotalRacesCons.innerHTML = "Number of finishes: " + relevantData.length + "<br><br>";
    }
    
    // Draws on the svg a label near the mouse location
    function drawOnMouseOverLabel(coords, svg, text, color, place, minPlace, maxPlace) {
        // Each text label will be inside a black outlined rect in g
        g = svg.append("g") 
            .attr("class", "rect_label");
        rect = g.append('rect')
            .attr("width", text.length*7)
            .attr("height", 20)
            .attr("stroke", "black")
            .style("fill", "white"); 
                            
        // Checks if to place the information on the right or on the left of the mouse location
        if (parseInt(place) <= (parseInt(minPlace)+ parseInt(maxPlace))/2) {
            rect.attr("x", coords[0]+6)
                .attr("y", coords[1]-30);
            g.append('text')
                .attr("x", coords[0]+10)
                .attr("y", coords[1]-15)
                .attr("fill", color)
                .text(text);
        }
        else {
            rect.attr("x", coords[0]-250)
                .attr("y", coords[1]-30);
            g.append('text')
                .attr("x", coords[0]-246)
                .attr("y", coords[1]-15)
                .attr("fill", color)
                .text(text);      
        }
    }                        
    
    // Writes the right text on the upper right section of the application
    function writeOnAbout(index) {
        if (index == 0) {
            about.innerHTML = "This VA application allows the user to find stats on Formula 1 drivers, so that they can gain a better knowledge of their skill and place in the sport.<br>";
            about.innerHTML += "<i>- Made by Luca Sannino as a project for Visual Analytics 2021 -</i>";
        }
        else if (index == 1) {
            about.innerHTML = "This bar chart shows the total points achieved by the selected driver per season. The user can also switch to the avg. points per race (per season) and interact with the bars by clicking them to calculate new averages on-the-fly.";
        }
        else if (index == 2) {
            about.innerHTML = "This bar chart shows how many times the selected driver has placed better than their teammates across the seasons. The user can also switch between race and qualifying results and interact with the legend to select a new driver.";
        }
        else if (index == 3) {
            about.innerHTML = "This lollipop chart shows the causes of DNFs. 'Physical' includes cases of external damage to the car (tyre punctures, broken wings etc.), while 'Mechanical' includes damage to the internal components."; 
        }
        else if (index == 4) {
            about.innerHTML = "This box-plot chart shows the distribution of the placements upon finishes. A quartile of the distribution (outliers excluded) falls in each of the four sections, meaning that the gray box represents ~50% of the placements.";
        }
        else {
            about.innerHTML = index;
        }
    }
        
    // Finds the points achieved by a driver season by season
    function findPointsAchieved(data) {
        // Groups all the results by pilot
        groupedResults = d3.nest()
            .key(function(d) {
                return d.surname + "_" + d.name;
            })
            .entries(data);

        // Finds the results of the selected pilot
        relevantResults = [];
        for (i = 0; i < groupedResults.length; i++) {
            driverResults = groupedResults[i];
            if (driverResults.key == selectedDriver) {
                relevantResults = driverResults.values;
            }
        }
        
        // Groups the relevant results by year/constructor and finds the total number of points by year/constructor
        if (showTotalPoints) {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.sum(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        // Groups the relevant results by year/constructor and finds the average number of points per race by year/constructor
        else {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.mean(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        
        /* DEBUG
        console.log(relevantResults); */
        
        return relevantResults;
    }
     
    // Finds how many times the current driver has won against his teammates
    function findWinsAgainstTeammates(data) {
        // Groups all the results by race and constructor
        groupedResults = d3.nest()
            .key(function(d) {
                return d.year + "_" + d.round + "_" + d.grandprix + "_" + d.constructor;
            })
            .entries(data);

        // Extracts the results of the selected driver and his teammate (or even teammates) for each race
        relevantResults = [];
        newTuples = [];
        for (i = 0; i < groupedResults.length; i++) {
            constructorResults = groupedResults[i].values;
            selectedDriverPosition = 0;
            name = "";
            surname = "";
            findTeammates = false;
            for (j = 0; j < constructorResults.length; j++) {
                if ((constructorResults[j].surname + "_" + constructorResults[j].name) == selectedDriver && findTeammates == false) {
                    relevantResults.push(constructorResults);
                    findTeammates = true;
                    selectedDriverPosition = constructorResults[j].position;
                    name = constructorResults[j].name;
                    surname = constructorResults[j].surname;
                    j = -1;
                }
                else if ((constructorResults[j].surname + "_" + constructorResults[j].name) != selectedDriver && findTeammates == true) {
                    newTuple = {
                        year: constructorResults[j].year,
                        round: constructorResults[j].round,
                        grandprix: constructorResults[j].grandprix,
                        constructor: constructorResults[j].constructor,
                        selectedDriverSurname: surname,
                        selectedDriverName: name,
                        selectedDriverPosition: selectedDriverPosition,
                        teammateSurname: constructorResults[j].surname,
                        teammateName: constructorResults[j].name,
                        teammatePosition: constructorResults[j].position
                        }
                    newTuples.push(newTuple);
                }
            }
        }
        
        // Transforms the data in the final form used by the chart
        relevantData = d3.nest()
            .key(function(d) {
                return d.year + "_" + d.teammateSurname + "_" + d.teammateName;
            })
            .rollup(function(d) {
                return {
                    selectedDriverWins: d3.sum(d, function(g) {
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition != "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition != "\\N" && g.teammatePosition == "\\N") {
                            return 1;
                        }
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition == "\\N") {
                            return 0;
                        }
                        if (parseInt(g.selectedDriverPosition) < parseInt(g.teammatePosition)) {
                            return 1;
                        }
                        return 0;
                    }),
                    teammateWins: d3.sum(d, function(g) {
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition != "\\N") {
                            return 1;
                        }
                        if (g.selectedDriverPosition != "\\N" && g.teammatePosition == "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition == "\\N") {
                            return 0;
                        }
                        if (parseInt(g.teammatePosition) < parseInt(g.selectedDriverPosition)) {
                            return 1;
                        }
                        return 0;
                    }),
               }
            })
            .entries(newTuples);   
                
        /* DEBUG
        console.log(relevantData); */
        
        return relevantData;
    }
    
    // Finds the reasons of DNFs for the selected driver
    function findDNFs(data, minYear, maxYear) {
        // Groups all the results by driver
        groupedResults = d3.nest()
            .key(function(d) {
                return d.surname + "_" + d.name;
            })
            .entries(data);
        
        // Finds the all the finish states of the selected pilot in the form of new tuples
        newTuples = [];
        for (i = 0; i < groupedResults.length; i++) {
            driverKey = groupedResults[i].key;
            if (driverKey == selectedDriver) {
                driverResults = groupedResults[i].values;
                for (j = 0; j < driverResults.length; j++) {
                    tuple = {
                            year: driverResults[j].year,
                            round: driverResults[j].round,
                            grandprix: driverResults[j].grandprix,
                            constructor: driverResults[j].constructor,
                            status: driverResults[j].status
                            }
                    newTuples.push(tuple);
                }
            }
        }
        
        // Transforms the data in the final form used by the chart
        physicalDamage = ["Accident", "Collision", "Collision Damage", "Spun off", 
                          "Puncture", "Suspension", "Tyre", "Front wing", 
                          "Broken wing", "Tyre puncture", "Rear wing", "Physical", 
                          "Damage", "Injured", "Injury", "Driver unwell", "Fatal accident"];
        retiredReasons = ["Retired", "Disqualified", "Did not qualify", "Safety", 
                          "Not classified", "Not restarted", "Safety concerns", "Excluded"];
        relevantData = d3.nest()
            .key(function(d) {
                return d.year;
            })
            .rollup(function(d) {
                return {
                    count: d3.sum(d, function(g) {
                        return 1;
                    }),
                    finished: d3.sum(d, function(g) {
                        if (g.status == "Finished" || g.status.substring(0, 1) == "+") {
                            return 1;
                        }
                        return 0;
                    }),
                    retired: d3.sum(d, function(g) {
                        if (retiredReasons.includes(g.status)) {
                            return 1;
                        }
                        return 0;
                    }),
                    physical: d3.sum(d, function(g) {
                        if (physicalDamage.includes(g.status)) {
                            return 1;
                        }
                        return 0;
                    }),
                    mechanical: d3.sum(d, function(g) {
                        if (g.status.substring(0, 1) != "+" && g.status != "Finished" && !retiredReasons.includes(g.status) && !physicalDamage.includes(g.status)) {
                            return 1;
                        }
                        return 0;
                    })
               }
            })
            .entries(newTuples);  
        
        // Sum the results of the selected years before returning the results
        countTotal = 0;
        finishedTotal = 0;
        retiredTotal = 0;
        physicalTotal = 0;
        mechanicalTotal = 0;
        woundsTotal = 0;
        for (i = 0; i < relevantData.length; i++) {
            year = relevantData[i].key;
            if (year >= minYear && year <= maxYear) {
                values = relevantData[i].value;
                countTotal += values.count;
                finishedTotal += values.finished;
                retiredTotal += values.retired;
                physicalTotal += values.physical;
                mechanicalTotal += values.mechanical;
                woundsTotal += values.wounds;
            }
        }
        
        // Makes the final results
        relevantResults = [];
        tuple = {key: "count", value: countTotal};
        relevantResults.push(tuple);
        tuple = {key: "finished", value: finishedTotal};
        relevantResults.push(tuple);
        tuple = {key: "Retirement", value: retiredTotal};
        relevantResults.push(tuple);
        tuple = {key: "Physical", value: physicalTotal};
        relevantResults.push(tuple);
        tuple = {key: "Mechanical", value: mechanicalTotal};
        relevantResults.push(tuple);
        
        /* DEBUG
        console.log(relevantResults); */
        
        return relevantResults;
    }
    
    // Finds the placements of the selected driver
    function findPlacements(data, minYear, maxYear) {
        // Groups all the results by pilot
        var groupedResults = d3.nest()
            .key(function(d) {
                return d.surname + "_" + d.name;
            })
            .entries(data);
        
        // Finds the results of the selected pilot between the chosen range of years
        var relevantResults = [];
        for (i = 0; i < groupedResults.length; i++) {
            var key = groupedResults[i].key;
            if (key == selectedDriver) {
                var values = groupedResults[i].values;
                for (j = 0; j < values.length; j++) {
                    if (values[j].year >= minYear && values[j].year <= maxYear && (values[j].status == "Finished" || values[j].status.substring(0, 1) == "+")) {
                        relevantResults.push(parseInt(values[j].position));
                    }
                }
            }
        }
        
        /* DEBUG
        console.log(relevantResults); */
        
        return relevantResults;   
    }
        
    
    drawTitle();
    </script>
    </body>
</html>