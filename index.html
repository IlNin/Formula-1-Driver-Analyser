<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>Formula 1 Driver Analyzer</title>
        <script type="text/javascript" src="d3.js" charset="utf-8"></script>
        <link rel="stylesheet" type="text/css" href="style.css"/>
	</head>
    
    <body>
    <script charset="utf-8"> 
    class Driver {
        surname;
        name;
        concatName;

        constructor(surname, name) {
            this.surname = surname;
            this.name = name;
            this.concatName = surname.replace(/_/g, ' ') + " " + name.replace(/_/g, ' ');
        }
    }
    
    // Global variables
    var container_dimensions = {width: 550, height: 250}; // width: 650
    var margins = {top: 20, right: 10, bottom: 40, left: 45};
    var chart_dimensions = {
            width: container_dimensions.width - margins.left - margins.right,
            height: container_dimensions.height - margins.top - margins.bottom
    };
    var barSize = 30;
    var legend_width = 119;
    
    var wrapper;
    var barSvg; // Svg for the points bars
    var svgLegend;
    
    var showActiveDrivers = true; // Flag that indicates to show only active drivers
    var showTotalPoints = true; // Flag that indicates to show the total points instead of the average per race
    var showWinsInRaces = true; // Flag that indicates to show the wins in races instead of qualifying
    
    var activeDrivers = []; // List of drivers loaded by the data that are active
    var retiredDrivers = []; // List of drivers loaded by the data that are retired
    
    var barsClicked = []; // List of bars clicked in the total points chart
    var nBarsClicked = 0;
    var cumulativePoints = 0;
    
    function contains(drivers, driver) {
        for (i = 0; i < drivers.length; i++) {
            currentDriver = drivers[i];
            if (drivers[i].name == driver.name && drivers[i].surname == driver.surname) {
                return i+1; 
            }
        }
        return 0;
    }
    
    // Draws the title screen above the charts
    function drawTitle() {
        // Creates the wrapper div that contains the div 'title'
        aboveWrapper = document.createElement('div');
        aboveWrapper.id = "abovewrapper";
        document.body.appendChild(aboveWrapper);
        
        // Creates the div 'title' which contains text, selections and buttons
        title = document.createElement('div');
        title.id = "title";
        title.innerHTML = "<h1>Formula 1 Driver Analyzer</h1>";
        aboveWrapper.appendChild(title);   
        
        // Creates the div 'menu' which allows the user to select a driver
        menu = document.createElement('div');
        menu.id = "menu";
        aboveWrapper.appendChild(menu);
        
        // Adds radios button in order to distinguish between active and retired drivers
        menu.innerHTML += "Choose between drivers that are: ";
        activeButton = document.createElement('input');
        activeButton.type = 'radio';
        activeButton.name = 'drivers';
        activeButton.id = 'active-drivers';
        activeButton.value = "active";
        label = document.createElement('label');
        label.innerHTML = "Active";
        menu.appendChild(activeButton);
        menu.appendChild(label);
        menu.innerHTML += "   ";
        
        retiredButton = document.createElement('input');
        retiredButton.type = 'radio';
        retiredButton.name = 'drivers';
        retiredButton.id = 'retired-drivers';
        retiredButton.value = "retired";
        label = document.createElement('label');
        label.innerHTML = "Retired";
        menu.appendChild(retiredButton);
        menu.appendChild(label);
        menu.innerHTML += "<br>";
        
        // Creates a selection for the drivers with a default option, and adds it to 'title'
        menu.innerHTML += "Please select a driver: ";

        selectDriver = document.createElement('select');
        selectDriver.id = "select-driver";
        selectDriver.style.width = "150px";
        defaultDriverOption = document.createElement('option');
        defaultDriverOption.value = 0;
        defaultDriverOption.innerHTML = "- DRIVER -";
        selectDriver.appendChild(defaultDriverOption);
        menu.appendChild(selectDriver);
        menu.innerHTML += "<br>";
        
         // Creates the search button, makes it disabled and adds it to 'title'
        searchButton = document.createElement('button');
        searchButton.id = "search";
        searchButton.innerHTML = "Search data!";
        searchButton.disabled = true;
        menu.appendChild(searchButton);
        
        about = document.createElement('div');
        about.id = "menu";
        aboveWrapper.appendChild(about);
        
        document.getElementById("active-drivers").checked = true; 
        loadData();
    }
    
    // Loads the data from the csv file
    function loadData() {
        d3.queue()
            .defer(d3.csv, "results.csv")
            .defer(d3.csv, "qualifying.csv")
            .await(function(error, data, data2) {
                // Prints the error in case something goes wrong
                if (error) {
                    console.log(error);
                }
                // Everything goes ok!
                else {
                    // Sort all the drivers in two list: one for the recent ones, the other for the past drivers
                    activeDrivers = []; // Will Contain all active drivers inside the csv file
                    retiredDrivers = []; // Will contain all retired drivers inside the csv file
                    data.forEach(function(d) { // Cycles through the data
                        d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                        d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                        driver = new Driver(d.surname, d.name);
                        if (d.year == 2019 && !contains(activeDrivers, driver)) {
                            activeDrivers.push(driver);
                            index = contains(retiredDrivers, driver);
                            if (index) {
                                retiredDrivers.splice(index-1, 1);
                            }
                        }
                        else if (d.year >= 1996 && !contains(retiredDrivers, driver) && !contains(activeDrivers, driver)) {
                            retiredDrivers.push(driver);
                        }
                    });
                    
                    data2.forEach(function(d) { // Cycles through the qualifying data
                        d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                        d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                    });
                    
                    // Sort all drivers in alphabetical order
                    activeDrivers.sort(function(a, b) {
                        if (a.surname < b.surname) { 
                            return -1; 
                        }
                        if (a.surname > b.surname) { 
                            return 1; 
                        }
                        return 0;
                    });
                    retiredDrivers.sort(function(a, b){
                        if (a.surname < b.surname) { 
                            return -1; 
                        }
                        if (a.surname > b.surname) {
                            return 1; 
                        }
                        return 0;
                    });
                
                    addDriversToTitle(); // Adds the events to the user's selections in the title now that the data is loaded
                    enableInputsToTitle(data, data2);
                }
            });
    }
    
    // Adds the correct list of drivers to the selection
    function addDriversToTitle() {
        if (showActiveDrivers) {
            for (i = 0; i < activeDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = activeDrivers[i].concatName;
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
        else {
            for (i = 0; i < retiredDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = retiredDrivers[i].concatName;
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
    }
    
    // Adds events to the interactions of the user with the title screen
    function enableInputsToTitle(data, data2) {
        document.getElementById("active-drivers").onclick = function() {
            showActiveDrivers = true;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("retired-drivers").onclick = function() {
            showActiveDrivers = false;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("select-driver").onchange = function() { 
            if (document.getElementById("select-driver").value > 0) {  // A valid driver is selected: enables search button
                document.getElementById("search").disabled = false;
            }
            else { // Default option selected: disables search button
                document.getElementById("search").disabled = true;
            }
        }
        search.onclick = function() { // Checks if the user clicks the search button
            value = document.getElementById("select-driver").value;
            if (showActiveDrivers) {
                surname = activeDrivers[value-1].surname;
                name = activeDrivers[value-1].name;
                initializeChartsLayout(data, data2, surname, name);
            }
            else {
                surname = retiredDrivers[value-1].surname;
                name = retiredDrivers[value-1].name;
                initializeChartsLayout(data, data2, surname, name);
            }
        }    
    }
    
    // Prepares the layouts of the charts before plotting data on them
    function initializeChartsLayout(data, data2, surname, name) {
        // Removes the previous layout and restores global variables
        if (document.body.contains(wrapper)) {
            wrapper.remove();
        }
        showTotalPoints = true;
        showWinsInRaces = true;
        
        // Initializes the middle wrapper
        wrapper = document.createElement('div');
        wrapper.id = "middlewrapper";
        wrapper.innerHTML += "<br>";
        document.body.append(wrapper);
        
        // Prepares all the layouts
        preparePointsAchieved(data, surname, name);    
        prepareComparisons(data, data2, surname, name);
    }
    
    // Prepares the layout for the points achieved chart
    function preparePointsAchieved(data, surname, name) { 
        // Initializes the div that contains the svg area for the points bars    
        svgDiv = document.createElement('div');
        svgDiv.id = "bargraph";
        svgDiv.innerHTML = "Points Per Season<br>";
        wrapper.append(svgDiv); 
        
        // Initalizes an empty svg for the points bars
        barSvg = d3.select('#bargraph')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Adds radios button in order to switch between total points and average points per race
        optionsDiv = document.createElement('div');
        svgDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        totalButton = document.createElement('input');
        totalButton.type = 'radio';
        totalButton.name = 'points';
        totalButton.id = 'total-points';
        totalButton.value = "total";
        label = document.createElement('label');
        label.innerHTML = "Total Points";
        optionsDiv.appendChild(totalButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";

        averageButton = document.createElement('input');
        averageButton.type = 'radio';
        averageButton.name = 'points';
        averageButton.id = 'average-points';
        averageButton.value = "average";
        label = document.createElement('label');
        label.innerHTML = "Average Points Per Race";
        optionsDiv.appendChild(averageButton);
        optionsDiv.appendChild(label);
        document.getElementById("total-points").checked = true;
        
        document.getElementById('total-points').onclick = function() {
            showTotalPoints = true;
            plotPointsAchieved(data, surname, name);
        }
        document.getElementById('average-points').onclick = function() {
            showTotalPoints = false;
            plotPointsAchieved(data, surname, name);
        }
      
        // Initializes the div for the points bar graph legend
        svgLegendDiv = document.createElement('div');
        svgLegendDiv.innerHTML = "Legend Table<br>";
        svgLegendDiv.id = "legendtable";
        wrapper.append(svgLegendDiv);
        
        // Initializes the empty svg for the bar graph legend
        svgLegend = d3.select('#legendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","legendtable");
        
        // Plots the bar graph that shows the points achieved by the driver season by season
        plotPointsAchieved(data, surname, name);
    }
          
    // Plot a bar graph that shows the points achieved by the driver season by season
    function plotPointsAchieved(data, surname, name) {
        // Erase previous data
        barSvg.selectAll('*').remove();
        barsClicked = []; 
        nBarsClicked = 0;
        cumulativePoints = 0
    
        // Finds the relevant data to plot
        relevantData = findPointsAchieved(data, surname, name);
  
        // Initializes the x scale
        minYear = relevantData[0].key;
        maxYear = relevantData[relevantData.length-1].key;
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key;
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        // Initializes the y scale
        maxPoints = 0;
        for (i = 0; i < relevantData.length; i++) {
            points = 0;
            for (j = 0; j < relevantData[i].values.length; j++) {
                points += relevantData[i].values[j].value.totalPoints;
            }
            if (points > maxPoints) {
                maxPoints = points;
            }
        }
        if (maxPoints == 0) {
            maxPoints = 1;
        }
        y = d3.scaleLinear()
            .domain([maxPoints, 0])
            .range([0, chart_dimensions.height]);
        
        // Initializes the colors
        colors = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yAxis = d3.axisLeft(y).ticks().tickFormat(d3.format("d"));
        
        // Appends the x axis
        barSvg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+(chart_dimensions.height)+")")
            .call(xAxis);
        barSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the y axis
        barSvg.append("g")
            .attr("class","y_axis")
            .call(yAxis)
        barSvg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.2em")
            .style("text-anchor","end")
            .text(function() {
                if (showTotalPoints) {
                    return "Total Points";
                }
                else {
                    return "Avg. Points Per Race";
                }
            });
       
        // Draws the bars
        constructors = []; // Keeps a list of constructors for the legend
        for (i = 0; i < relevantData.length; i++) { // Cycles through the years
            year = relevantData[i].key;
            for (j = 0; j < relevantData[i].values.length; j++) { // Cycles through the constructors per year
                constructor = relevantData[i].values[j].key;
                
                // Behind the scenes stuff
                if (!constructors.includes(constructor) && relevantData[i].values[j].value.totalPoints > 0) { // Filters out constructors with zero points
                    constructors.push(constructor);
                } 
                if (j > 0) { // Check if there's a bar below (aka a constructor change in the season) and if so, it takes its measures
                    barBelowY = relevantData[i].values[j-1].value.totalPoints;
                }
                
                // Draws the bar
                bar = barSvg.selectAll("bar")
                    .data([relevantData[i].values[j].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", constructor + year)
                        .style("fill", function(d) {
                            return colors(constructor);
                        })
                        .style("opacity", function(d) {
                            if (d.totalPoints == 0) {
                                return 0; }
                            else {
                                return 1;
                            }
                        })
                        .attr("stroke-width", 3)
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", y(0))
                        .attr("height", 0);
                        
                // Handles the animations
                drawInvisibleBar = true; // Flag that indicates to draw an invisible bar in case there are no points (so that labels can still appear)
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) { 
                        if (j > 0) { // If there's a bar below, stack the new bar above it
                            return y(d.totalPoints + barBelowY);
                        }
                        if (d.totalPoints == 0) { // Check if to draw an invisible bar
                            for (z = j; z < relevantData[i].values.length; z++) { // Checks if the driver got points with other constructors in that year
                                if (relevantData[i].values[z].value.totalPoints > 0) {
                                    drawInvisibleBar = false; // Can't draw a bar since there's will be a visible bar later for this year
                                }
                            }
                            if (drawInvisibleBar) {
                                return y(maxPoints);
                            }
                        }
                        return y(d.totalPoints); 
                    })
                    .attr("height", function(d) { 
                        if (j > 0) {
                            return y(barBelowY) - y(d.totalPoints+barBelowY);
                        }
                        if (d.totalPoints == 0 && drawInvisibleBar) { // Invisible bar
                            return chart_dimensions.height - y(maxPoints);
                        }
                        return chart_dimensions.height - y(d.totalPoints); 
                    });
                
                // Handles inputs                 
                bar.on("mouseover", function(d) {
                    /* BUG
                    d3.select(this)
                        .style("stroke", "black"); */
                    
                    // Draws a label with information about the bar
                    coords = d3.mouse(this);
                    classLength = d3.select(this).attr("class").length;
                    constructor = d3.select(this).attr("class").substring(0, classLength-4);
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    text = "[Points: " + d.totalPoints.toFixed(2) + ", Constructor: " + constructor.replace(/_/g, ' ') + "]";
                    drawOnMouseOverLabel(coords, barSvg, text, colors(constructor), year, minYear, maxYear);
                });
                   
                bar.on("mouseout", function(d) {
                    /* BUG
                    if (!barsClicked.includes(d3.select(this).attr("class"))) {
                        d3.select(this)
                            .style("stroke", "none"); 
                    } */
                                
                    // Removes the label with information about the bar
                    d3.select(".rect_label")
                        .remove();
                });
                
                bar.on("click", function(d) {
                    // Selects the bar clicked, and also the other bars in the same year
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    selection = d3.selectAll("[class$='" + year + "']");
                    
                    // Calculates the total number of points to add/remove to the average
                    points = selection.data();
                    totalPoints = 0;
                    for (i = 0; i < points.length; i++) {
                        totalPoints += points[i].totalPoints;
                    }
                    
                    // Gives them a stroke if they have been selected for the first time, otherwise removes the previous stroke
                    add = true; // Flag that indicates if to increase or decrease the total number of points across the season 
                    selection
                        .attr("stroke", function(d) {
                            currentClass = d3.select(this).attr("class");
                            if (!barsClicked.includes(currentClass)) {
                                // console.log("Adding: " + currentClass);
                                barsClicked.push(currentClass);
                                return "black";
                            }
                            else {
                                add = false;
                                // console.log("Removing: " + currentClass);
                                index = barsClicked.indexOf(currentClass);
                                barsClicked.splice(index, 1);
                                return "null";
                            }
                        })
                        .style("opacity", function(d) {
                            if (d3.select(this).style("opacity") == 0) {
                                return 0.1;
                            }
                            else if (d3.select(this).style("opacity") == 0.1) {
                                return 0;
                            }
                       });
                    
                    // Calculates the total number of points to add/remove to the cumulative points across the seasons
                    points = selection.data();
                    if (add) {
                        nBarsClicked += 1;
                        for (i = 0; i < points.length; i++) {
                            cumulativePoints += points[i].totalPoints;
                        }
                    }
                    else {
                        nBarsClicked -= 1;
                        for (i = 0; i < points.length; i++) {
                            cumulativePoints -= points[i].totalPoints;
                        }
                    }
                    
                    // DEBUG
                    console.log("[" + cumulativePoints + ", " + nBarsClicked + "]"); 
                    
                    // Adds/update a mean line in the total points bar chart
                    d3.select(".mean").remove()
                    
                    if (nBarsClicked > 0) {
                        mean = cumulativePoints/nBarsClicked;
                        barSvg.append("line")
                            .attr("class", "mean")
                            .attr("x1", 0)
                            .attr("y1", y(mean))
                            .attr("x2", chart_dimensions.width)
                            .attr("y2", y(mean))
                            .style("stroke", "red")
                            .style("stroke-width", 3)
                            .on("mouseover", function(d) {
                                coords = d3.mouse(this);
                                text = "[Mean: " + mean.toFixed(2) + ", Sum: " + cumulativePoints.toFixed(2) + "] ";
                                drawOnMouseOverLabel(coords, barSvg, text, "red", year, minYear, maxYear);
                            })
                            .on("mouseout", function(d) {
                                d3.select(".rect_label")
                                    .remove();
                            });
                    }
                });
            }        
        }
        
        // Draws the legend for the graph
        drawPointsAchievedLegend(constructors);      
    }
        
    // Draws the legend for the points bar graph
    function drawPointsAchievedLegend(constructors) {
        // Erase previous data
        svgLegend.selectAll('*').remove();
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgLegend.selectAll("legend")
            .data(constructors)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*10)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colors(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
            
        /* Add input events to the legend
        legend
            .on("mouseover", function(d) {
                // Highlights the entry in the legend and outlines the right bars
                d3.select(".rect"+d)
                    .attr("stroke", "black");
                d3.select(".text"+d)
                    .attr("text-decoration", "underline overline");
                for (i = 1950; i <= 2019; i++) {
                    d3.select("." + d + i)
                        .attr("stroke", "black");                   
                } 
            })
            .on("mouseout", function(d) {
                // Restores everything
                d3.select(".rect"+d)
                    .attr("stroke", "none");
                d3.select(".text"+d)
                    .attr("text-decoration", "none");
                for (i = 1950; i <= 2019; i++) {
                    d3.select("." + d + i)
                        .attr("stroke", "none");
                } 
            }); */
    }
    
    // Prepares the layout for the comparisons with teammates chart
    function prepareComparisons(data, data2, surname, name) {
        // Initializes the div that contains the svg area for the comparisons   
        svgCmpDiv = document.createElement('div');
        svgCmpDiv.id = "comparisons";
        svgCmpDiv.innerHTML = "Wins/Losses Against Teammates<br>";
        wrapper.append(svgCmpDiv); 
        
        // Initalizes an empty svg for the points bars
        cmpSvg = d3.select('#comparisons')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Adds radios button in order to switch between total points and average points per race
        optionsDiv = document.createElement('div');
        svgCmpDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        winsRacesButton = document.createElement('input');
        winsRacesButton.type = 'radio';
        winsRacesButton.name = 'races-or-quali';
        winsRacesButton.id = 'show-races';
        winsRacesButton.value = "races";
        label = document.createElement('label');
        label.innerHTML = "Wins In Races";
        optionsDiv.appendChild(winsRacesButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";

        winsQualiButton = document.createElement('input');
        winsQualiButton.type = 'radio';
        winsQualiButton.name = 'races-or-quali';
        winsQualiButton.id = 'show-quali';
        winsQualiButton.value = "quali";
        label = document.createElement('label');
        label.innerHTML = "Wins In Qualifying";
        optionsDiv.appendChild(winsQualiButton);
        optionsDiv.appendChild(label);
        document.getElementById("show-races").checked = true;
        
         document.getElementById('show-races').onclick = function() {
            showWinsInRaces = true;
            plotComparisons(data, data2, surname, name);
        }
        document.getElementById('show-quali').onclick = function() {
            showWinsInRaces = false;
            plotComparisons(data, data2, surname, name);
        }
        
        // Initializes the div for the points bar graph legend
        svgCmpLegendDiv = document.createElement('div');
        svgCmpLegendDiv.innerHTML = "Legend Table<br>";
        svgCmpLegendDiv.id = "cmplegendtable";
        wrapper.append(svgCmpLegendDiv);
        
        // Initializes the empty svg for the bar graph legend
        svgCmpLegend = d3.select('#cmplegendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","cmplegendtable");
        
        // Plots a bar graph that shows the comparisons with teammates
        plotComparisons(data, data2, surname, name);
    }
    
    // Plots a bar graph that shows the comparisons with teammates
    function plotComparisons(data, data2, surname, name) {
        // Erase previous data
        cmpSvg.selectAll('*').remove();
        
        // Finds the relevant data to plot
        relevantData = [];
        if (showWinsInRaces) {
            relevantData = findWinsAgainstTeammates(data, surname, name);
        }
        else {
            relevantData = findWinsAgainstTeammates(data2, surname, name);
        }
        
        // Initializes the x scale
        minYear = relevantData[0].key.substring(0, 4);
        maxYear = relevantData[relevantData.length-1].key.substring(0, 4);
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key.substring(0, 4);
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        // Initializes the y scale
        maxWins = 0;
        previousYear = 0;
        topWins = 0;
        bottomWins = 0;
        for (i = 0; i < relevantData.length; i++) {
            year = relevantData[i].key.substring(0, 4);
            if (year != previousYear) {
                previousYear = year;
                topWins = 0;
                bottomWins = 0;
            }
            topWins += relevantData[i].value.selectedDriverWins;
            if (topWins > maxWins) {
                maxWins = topWins;
            }
            bottomWins += relevantData[i].value.teammateWins;
            if (bottomWins > maxWins) {
                maxWins = bottomWins;
            }
        }
        if (maxWins == 0) {
            maxWins = 1;
        }
        yTop = d3.scaleLinear()
            .domain([maxWins, 0])
            .range([0, chart_dimensions.height/2]);
        
        yBottom = d3.scaleLinear()
            .domain([0, maxWins])
            .range([0, chart_dimensions.height/2]);
        
        // Initializes the colors
        colorsTeammates = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yTopAxis = d3.axisLeft(yTop).ticks(4).tickFormat(d3.format("d"));
        yBottomAxis = d3.axisLeft(yBottom).ticks(4).tickFormat(d3.format("d"));
        
        // Appends the x axis
        cmpSvg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+ (chart_dimensions.height) +")")
            .call(xAxis);
        cmpSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the top y axis
        cmpSvg.append("g")
            .attr("class","yTop_axis")
            .call(yTopAxis)
        cmpSvg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.5em")
            .style("text-anchor","end")
            .style("font", "12px times")
            .text(function(d) {
                if (showWinsInRaces) {
                    return "Wins In Races";
                }
                else {
                    return "Wins In Qualy";
                }
            });
        
        // Appends the bottom y axis
        cmpSvg.append("g")
            .attr("transform", "translate(0," + (chart_dimensions.height)/2 + ")")
            .attr("class","yBottom_axis")
            .call(yBottomAxis); 
        cmpSvg.append("text")
            .attr("class","label")
            .attr("transform", "translate(0," + (chart_dimensions.height) + ")" + "rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.5em")
            .style("text-anchor","start")
            .style("font", "12px times")
            .text(function(d) {
                if (showWinsInRaces) {
                    return "Losses In Qualy";
                }
                else {
                    return "Losses In Qualy";
                }
            });
        
        // Plot the data
        teammates = []; // Contains the list of drivers involved in the comparison
        teammates.push(surname + " " + name);
        previousYear = 0; // Previous year found while cycling through the data
        barBelowTopY = 0; // Size of the bar on the top Y if there's one below the current one
        barAboveBottomY = 0; // Size of the bar on the bottom Y if there's one above the current one
        for (i = 0; i < relevantData.length; i++) {
            year = relevantData[i].key.substring(0, 4);
            
            // Check if there are more teammates in the same year (aka if there are already bars in place)
            if (year != previousYear) {
                previousYear = year;
                barBelowTopY = 0;
                barAboveBottomY = 0;
            }
            else {
                barBelowTopY += relevantData[i-1].value.selectedDriverWins;
                barAboveBottomY += relevantData[i-1].value.teammateWins;
            }
            
            // Refresh the list of teammates
            teammate = relevantData[i].key.substring(5, relevantData[i].key.length);
            if (!teammates.includes(teammate) && relevantData[i].value.teammateWins > 0) {
                teammates.push(teammate);
            }
            
            // Plot selected driver and teammate
            for (j = 0; j < 2; j++) {           
                bar = cmpSvg.selectAll("bar")
                    .data([relevantData[i].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", function(d) {
                            if (j == 0) { // Index 0 means this is the selected driver
                                return "0" + relevantData[i].key;
                            }
                            else { // Index 1 means this is the teammate
                                return "1" + relevantData[i].key;
                            }
                        })
                        .style("fill", function(d) {
                            if (j == 0) {
                                return colorsTeammates(surname + " " + name);
                            }
                            else {
                                return colorsTeammates(teammate);
                            }
                        })
                        .style("stroke", "white")
                        .style("stroke-width", 1)
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", yTop(0))
                        .attr("height", 0);
                
                // Handles animation
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) {
                        if (j == 0) {
                            return yTop(d.selectedDriverWins + barBelowTopY);
                        }
                        else {
                            return yTop(-barAboveBottomY);
                        }
                    })
                    .attr("height", function(d) {
                        if (j == 0) {
                            if (barBelowTopY == 0) {
                                return chart_dimensions.height/2 - yTop(d.selectedDriverWins);
                            }
                            else {
                                return yTop(barBelowTopY) - yTop(d.selectedDriverWins + barBelowTopY);
                            }
                        }
                        else {
                            return yBottom(d.teammateWins);
                       }
                    });
                    
              
                // Handles inputs
                bar.on("mouseover", function(d) {
                    // Draws a label with information about the bar
                    coords = d3.mouse(this);
                    id = d3.select(this).attr("class");
                    flagTop = id.substring(0, 1);
                    year = id.substring(1, 5);
                    teammate = id.substring(6, id.length);
                    text = "";
                    color = "";
                    if (flagTop == "0") {     
                        text = "[Wins against " + teammate.replace(/_/g, ' ') + ": " + d.selectedDriverWins + "] ";
                        color = colorsTeammates(surname + " " + name);
                    }
                    else {
                        text = "[Losses against " + teammate.replace(/_/g, ' ') + ": " + d.teammateWins + "] ";
                        color = colorsTeammates(teammate);
                    }
                    drawOnMouseOverLabel(coords, cmpSvg, text, color, year, minYear, maxYear);
                });
                
                bar.on("mouseout", function(d) {
                    d3.select(".rect_label")
                        .remove();
                });             
            }
        }  

        // Draws the legend
        drawComparisonLegend(teammates);
    }
    
    // Draws the legend for the comparison graph
    function drawComparisonLegend(teammates) {
        // Erase previous data
        svgCmpLegend.selectAll('*').remove();
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgCmpLegend.selectAll("legend")
            .data(teammates)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*5)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colorsTeammates(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .style("font", "12px times")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
    }
    
    // Draws on the svg a label near the mouse location
    function drawOnMouseOverLabel(coords, svg, text, color, place, minPlace, maxPlace) {
        // Each text label will be inside a black outlined rect in g
        g = svg.append("g") 
            .attr("class", "rect_label");
        rect = g.append('rect')
            .attr("width", text.length*7)
            .attr("height", 20)
            .attr("stroke", "black")
            .style("fill", "white"); 
                            
        // Checks if to place the information on the right or on the left of the mouse location
        if (parseInt(place) <= (parseInt(minPlace)+ parseInt(maxPlace))/2) {
            rect.attr("x", coords[0]+6)
                .attr("y", coords[1]-30);
            g.append('text')
                .attr("x", coords[0]+10)
                .attr("y", coords[1]-15)
                .attr("fill", color)
                .text(text);
        }
        else {
            rect.attr("x", coords[0]-250)
                .attr("y", coords[1]-30);
            g.append('text')
                .attr("x", coords[0]-246)
                .attr("y", coords[1]-15)
                .attr("fill", color)
                .text(text);      
        }
    }                        
        
    // Finds the points achieved by a driver season by season
    function findPointsAchieved(data, surname, name) {
        // Groups all the results by pilot
        groupedResults = d3.nest()
            .key(function(d) {
                return d.surname + "_" + d.name;
            })
            .entries(data);

        // Finds the results of the selected pilot
        relevantResults = [];
        for (i = 0; i < groupedResults.length; i++) {
            driverResults = groupedResults[i];
            if (driverResults.key == surname + "_" + name) {
                relevantResults = driverResults.values;
            }
        }
        
        // Groups the relevant results by year/constructor and finds the total number of points by year/constructor
        if (showTotalPoints) {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.sum(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        // Groups the relevant results by year/constructor and finds the average number of points per race by year/constructor
        else {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.mean(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        
        /* DEBUG
        console.log(relevantResults); */
        return relevantResults;
    }
     
    // Finds how many times the current driver has won against his teammates
    function findWinsAgainstTeammates(data, surname, name) {
        // Groups all the results by race and constructor
        groupedResults = d3.nest()
            .key(function(d) {
                return d.year + "_" + d.round + "_" + d.grandprix + "_" + d.constructor;
            })
            .entries(data);
        
        // Extracts the results of the selected driver and his teammate (or even teammates) for each race
        relevantResults = [];
        newTuples = [];
        for (i = 0; i < groupedResults.length; i++) {
            constructorResults = groupedResults[i].values;
            selectedDriverPosition = 0;
            findTeammates = false;
            for (j = 0; j < constructorResults.length; j++) {
                if (constructorResults[j].surname == surname && constructorResults[j].name == name && findTeammates == false) {
                    relevantResults.push(constructorResults);
                    findTeammates = true;
                    selectedDriverPosition = constructorResults[j].position;
                    j = -1;
                }
                else if (constructorResults[j].surname != surname && findTeammates == true) {
                    newTuple = {
                        year: constructorResults[j].year,
                        round: constructorResults[j].round,
                        grandprix: constructorResults[j].grandprix,
                        constructor: constructorResults[j].constructor,
                        selectedDriverSurname: surname,
                        selectedDriverName: name,
                        selectedDriverPosition: selectedDriverPosition,
                        teammateSurname: constructorResults[j].surname,
                        teammateName: constructorResults[j].name,
                        teammatePosition: constructorResults[j].position
                        }
                    newTuples.push(newTuple);
                }
            }
        }
        
        // Transforms the data in the final form used by the chart
        relevantData = d3.nest()
            .key(function(d) {
                return d.year + "_" + d.teammateSurname + "_" + d.teammateName;
            })
            .rollup(function(d) {
                return {
                    selectedDriverWins: d3.sum(d, function(g) {
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition != "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition != "\\N" && g.teammatePosition == "\\N") {
                            return 1;
                        }
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition == "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition < g.teammatePosition) {
                            return 1;
                        }
                        return 0;
                    }),
                    teammateWins: d3.sum(d, function(g) {
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition != "\\N") {
                            return 1;
                        }
                        if (g.selectedDriverPosition != "\\N" && g.teammatePosition == "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition == "\\N") {
                            return 1;
                        }
                        if (g.teammatePosition < g.selectedDriverPosition) {
                            return 1;
                        }
                        return 0;
                    }),
               }
            })
            .entries(newTuples);   
                
        console.log(relevantData);
        return relevantData;
    }
        
    drawTitle();
    </script>
    </body>
</html>