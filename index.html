<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>Formula 1 Driver Analyzer</title>
        <script type="text/javascript" src="d3.js" charset="utf-8"></script>
        <style>
            #abovewrapper {
                width: fit-content;
                display: flex;
            }
            #title {
                border: 3px solid black;
                width: 435px;
                padding-left: 5px;
                padding-right: 5px;
                padding-bottom: 5px;
                display: inline-block;
                background: yellow;
                text-align: center;
                animation-name: fadeInOpacity;
                animation-iteration-count: 1;
                animation-timing-function: ease-in;
                animation-duration: 2s;
            }
             #menu {
                border: 3px solid black;
                width: 435px;
                border-left: none;
                padding-left: 5px;
                padding-right: 5px;
                padding-bottom: 5px;
                padding-top: 10px;
                display: inline-block;
                background: yellow;
                text-align: center;
                animation-name: fadeInOpacity;
                animation-iteration-count: 1;
                animation-timing-function: ease-in;
                animation-duration: 2s;
            }
            #middlewrapper {
                display: flex;
                border: 3px solid black;
                border-top: 1px solid black;
                width: fit-content;
                text-align: center;
                animation-name: fadeInOpacity;
                animation-iteration-count: 1;
                animation-timing-function: ease-in;
                animation-duration: 2s;
            }  
            #bargraph {
                padding-top: 6px;
                display: inline-block;
                text-align: center;
            }
             #legendtable {
                padding-top: 6px;
                display: inline-block;
                text-align: center;
            }
            
            @keyframes fadeInOpacity {
                0% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }
        </style>
	</head>
    
    <body>
    <script charset="utf-8"> 
    class Driver {
        surname;
        name;
        concatName;

        constructor(surname, name) {
            this.surname = surname;
            this.name = name;
            this.concatName = surname + " " + name;
        }
    }
    
    // Global variables
    var container_dimensions = {width: 550, height: 250}; // width: 650
    var margins = {top: 20, right: 20, bottom: 40, left: 45};
    var chart_dimensions = {
            width: container_dimensions.width - margins.left - margins.right,
            height: container_dimensions.height - margins.top - margins.bottom
    };
    var barSize = 30;
    var legend_width = 130;
    
    var showActiveDrivers = true; // Flag that indicates to show only active drivers
    var activeDrivers = []; // List of drivers loaded by the data that are active
    var retiredDrivers = []; // List of drivers loaded by the data that are retired
    
    function contains(drivers, driver) {
        for (i = 0; i < drivers.length; i++) {
            currentDriver = drivers[i];
            if (drivers[i].name == driver.name && drivers[i].surname == driver.surname) {
                return i+1; 
            }
        }
        return 0;
    }
    
    // Draws the title screen above the charts
    function drawTitle() {
        // Creates the wrapper div that contains the div 'title'
        aboveWrapper = document.createElement('div');
        aboveWrapper.id = "abovewrapper";
        document.body.appendChild(aboveWrapper);
        
        // Creates the div 'title' which contains text, selections and buttons
        title = document.createElement('div');
        title.id = "title";
        title.innerHTML = "<h1>Formula 1 Driver Analyzer</h1>";
        aboveWrapper.appendChild(title);   
        
        // Creates the div 'menu' which allows the user to select a driver
        menu = document.createElement('div');
        menu.id = "menu";
        aboveWrapper.appendChild(menu);
        
        // Adds radios button in order to distinguish between active and retired drivers
        menu.innerHTML += "Choose between drivers that are: ";
        activeButton = document.createElement('input');
        activeButton.type = 'radio';
        activeButton.name = 'drivers';
        activeButton.id = 'active-drivers';
        activeButton.value = "active";
        label = document.createElement('label');
        label.innerHTML = "Active";
        menu.appendChild(activeButton);
        menu.appendChild(label);
        menu.innerHTML += "   ";
        
        retiredButton = document.createElement('input');
        retiredButton.type = 'radio';
        retiredButton.name = 'drivers';
        retiredButton.id = 'retired-drivers';
        retiredButton.value = "retired";
        label = document.createElement('label');
        label.innerHTML = "Retired";
        menu.appendChild(retiredButton);
        menu.appendChild(label);
        menu.innerHTML += "<br>";
        
        // Creates a selection for the drivers with a default option, and adds it to 'title'
        menu.innerHTML += "Please select a driver: ";

        selectDriver = document.createElement('select');
        selectDriver.id = "select-driver";
        defaultDriverOption = document.createElement('option');
        defaultDriverOption.value = 0;
        defaultDriverOption.innerHTML = "- DRIVER -";
        selectDriver.appendChild(defaultDriverOption);
        menu.appendChild(selectDriver);
        menu.innerHTML += "<br>";
        
         // Creates the search button, makes it disabled and adds it to 'title'
        searchButton = document.createElement('button');
        searchButton.id = "search";
        searchButton.innerHTML = "Search data!";
        searchButton.disabled = true;
        menu.appendChild(searchButton);
        
        about = document.createElement('div');
        about.id = "menu";
        aboveWrapper.appendChild(about);
        
        document.getElementById("active-drivers").checked = true; 
        loadData();
    }
    
    // Loads the data from the csv file
    function loadData() {
        d3.csv("results.csv", function(error, data) {
            // Prints the error in case something goes wrong
            if (error) {
                console.log(error);
            }
            // Everything goes ok!
            else {
                activeDrivers = []; // Will Contain all active drivers inside the csv file
                retiredDrivers = []; // Will contain all retired drivers inside the csv file
                data.forEach(function(d) { // Cycles through the data
                    d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                    d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                    driver = new Driver(d.surname, d.name);
                    if (d.year == 2019 && !contains(activeDrivers, driver)) {
                        activeDrivers.push(driver);
                        index = contains(retiredDrivers, driver);
                        if (index) {
                            retiredDrivers.splice(index-1, 1);
                        }
                    }
                    else if (!contains(retiredDrivers, driver) && !contains(activeDrivers, driver)) {
                        retiredDrivers.push(driver);
                    }
                });
                activeDrivers.sort(function(a, b){
                    if(a.surname < b.surname) { return -1; }
                    if(a.surname > b.surname) { return 1; }
                    return 0;
                });
                retiredDrivers.sort(function(a, b){
                    if(a.surname < b.surname) { return -1; }
                    if(a.surname > b.surname) { return 1; }
                    return 0;
                });
                //console.log(activeDrivers);
                //console.log(retiredDrivers);
                addDriversToTitle(); // Adds the events to the user's selections in the title now that the data is loaded
                enableInputsToTitle(data);
            }
        });
    }
    
    // Adds the correct list of drivers to the selection
    function addDriversToTitle() {
        if (showActiveDrivers) {
            for (i = 0; i < activeDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = activeDrivers[i].concatName;
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
        else {
            for (i = 0; i < retiredDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = retiredDrivers[i].concatName;
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
    }
    
    // Adds events to the interactions of the user with the title screen
    function enableInputsToTitle(data) {
        document.getElementById("active-drivers").onclick = function() {
            showActiveDrivers = true;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("retired-drivers").onclick = function() {
            showActiveDrivers = false;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("select-driver").onchange = function() { 
            if (document.getElementById("select-driver").value > 0) {  // A valid driver is selected: enables search button
                document.getElementById("search").disabled = false;
            }
            else { // Default option selected: disables search button
                document.getElementById("search").disabled = true;
            }
        }
        search.onclick = function() { // Checks if the user clicks the search button
            value = document.getElementById("select-driver").value;
            if (showActiveDrivers) {
                surname = activeDrivers[value-1].surname;
                name = activeDrivers[value-1].name;
                plotPointsAchieved(data, surname, name);
            }
            else {
                surname = retiredDrivers[value-1].surname;
                name = retiredDrivers[value-1].name;
                plotPointsAchieved(data, surname, name);
            }
        }    
    }
    
    // Plot a bar graph that shows the points achieved by the driver season by season
    function plotPointsAchieved(data, surname, name) {
        // Removes the previous graph and option screen
        previousGraph = document.getElementById("middlewrapper");
        if (document.body.contains(previousGraph)) {
            previousGraph.remove();
        }
    
        // Finds the relevant data to plot
        relevantData = findPointsAchieved(data, surname, name);
        
        // Initializes the wrapper and the empty svg area
        wrapper = document.createElement('div');
        wrapper.id = "middlewrapper";
        wrapper.innerHTML += "<br>";
        document.body.append(wrapper);
        
        svgDiv = document.createElement('div');
        svgDiv.id = "bargraph";
        svgDiv.innerHTML = "Total Points Per Season<br>";
        wrapper.append(svgDiv); 
        
        svg = d3.select('#bargraph')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Initializes the scales and colors
        minYear = relevantData[0].key;
        maxYear = relevantData[relevantData.length-1].key;
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key;
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        maxPoints = 0;
        for (i = 0; i < relevantData.length; i++) {
            points = 0;
            for (j = 0; j < relevantData[i].values.length; j++) {
                points += relevantData[i].values[j].value.totalPoints;
            }
            if (points > maxPoints) {
                maxPoints = points;
            }
        }     
        y = d3.scaleLinear()
            .domain([maxPoints, 0])
            .range([0, chart_dimensions.height]);
        
        colors = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yAxis = d3.axisLeft(y).ticks().tickFormat(d3.format("d"));
        
        // Appends the x axis
        svg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+(chart_dimensions.height)+")")
            .call(xAxis);
        svg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the y axis
        svg.append("g")
            .attr("class","y_axis")
            .call(yAxis)
        svg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.2em")
            .style("text-anchor","end")
            .text("Total Points");
       
        // Draws the bars
        constructors = []; // Keeps a list of constructors for the legend
        for (i = 0; i < relevantData.length; i++) { // Cycles through the years
            year = relevantData[i].key;
            for (j = 0; j < relevantData[i].values.length; j++) { // Cycles through the constructors per year
                constructor = relevantData[i].values[j].key;
                if (!constructors.includes(constructor) && relevantData[i].values[j].value.totalPoints > 0) { // Filters out constructors with zero points
                    console.log(relevantData[i].values[j].value.totalPoints);
                    constructors.push(constructor);
                } 
                if (j > 0) { // Check if there's a bar below (aka a constructor change in the season) and if so, it takes its measures
                    barBelowY = relevantData[i].values[j-1].value.totalPoints;
                }
                bar = svg.selectAll("bar")
                    .data([relevantData[i].values[j].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", constructor + year)
                        .style("fill", function(d) {
                            return colors(constructor);
                        })
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", y(0))
                        .attr("height", 0);
                 
                // Handles inputs                 
                bar.on("mouseover", function(d) {
                    d3.select(this)
                        .style("stroke", "black");
                    coords = d3.mouse(this);
                            
                    // Adds information about the points near the mouse location
                    g = svg.append("g") // Each text label will be inside a black outlined rect in g
                        .attr("class", "rect_label");
                    classLength = d3.select(this).attr("class").length;
                    constructor = d3.select(this).attr("class").substring(0, classLength-4);
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    text = "[Points: " + d.totalPoints + ", Constructor: " + constructor.replace(/_/g, ' ') + "]";
                    rect = g.append('rect')
                        .attr("width", text.length*7)
                        .attr("height", 20)
                        .attr("stroke", "black")
                        .style("fill", "white"); 
                            
                    // Checks if to place the information on the right or on the left of the mouse location
                    if (parseInt(year) <= (parseInt(minYear)+ parseInt(maxYear))/2) {
                        rect.attr("x", coords[0]+6)
                            .attr("y", coords[1]-30);
                        g.append('text')
                            .attr("x", coords[0]+10)
                            .attr("y", coords[1]-15)
                            .attr("fill", colors(constructor))
                            .text(text);
                        }
                        else {
                            rect.attr("x", coords[0]-200)
                                .attr("y", coords[1]-30);
                             g.append('text')
                                .attr("x", coords[0]-196)
                                .attr("y", coords[1]-15)
                                .attr("fill", colors(constructor))
                                .text(text);      
                        }              
                    })
                   
                bar.on("mouseout", function(d) {
                    d3.select(this)
                        .style("stroke", "none");
                                
                    // Removes information about the points near the mouse location
                    d3.select(".rect_label")
                        .remove();
                });
               
                // Handles the animations
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) { 
                        if (j > 0) { // If there's a bar below, stack the new bar above it
                            return y(d.totalPoints + barBelowY);
                        }
                        return y(d.totalPoints); 
                    })
                    .attr("height", function(d) { 
                        if (j > 0) {
                            return y(barBelowY) - y(d.totalPoints+barBelowY);
                        }
                        return chart_dimensions.height - y(d.totalPoints); 
                    })
            }        
        }
        
        // Draws the legend for the graph
        plotPointsAchievedLegend(constructors);
        
        // Adds radios button in order to switch between total points and average points per race
        optionsDiv = document.createElement('div');
        svgDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        totalButton = document.createElement('input');
        totalButton.type = 'radio';
        totalButton.name = 'points';
        totalButton.id = 'total-points';
        totalButton.value = "total";
        label = document.createElement('label');
        label.innerHTML = "Total Points";
        optionsDiv.appendChild(totalButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";
 

        averageButton = document.createElement('input');
        averageButton.type = 'radio';
        averageButton.name = 'points';
        averageButton.id = 'average-points';
        averageButton.value = "average";
        label = document.createElement('label');
        label.innerHTML = "Average Points Per Race";
        optionsDiv.appendChild(averageButton);
        optionsDiv.appendChild(label);
        document.getElementById("total-points").checked = true;
    }
        
    // Draws the legend for the points bar graph
    function plotPointsAchievedLegend(constructors) {
        // Initializes the empty svg area
        wrapper = document.getElementById("middlewrapper");
        svgLegendDiv = document.createElement('div');
        svgLegendDiv.innerHTML = "Legend Table<br>";
        svgLegendDiv.id = "legendtable";
        wrapper.append(svgLegendDiv);
        
        svgLegend = d3.select('#legendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","legendtable");
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgLegend.selectAll("legend")
            .data(constructors)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*10)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colors(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
            
        /* Add input events to the legend
        legend
            .on("mouseover", function(d) {
                // Highlights the entry in the legend and outlines the right bars
                d3.select(".rect"+d)
                    .attr("stroke", "black");
                d3.select(".text"+d)
                    .attr("text-decoration", "underline overline");
                d3.select("." + d + 2019)
                        .attr("stroke", "black");
                for (i = 1950; i <= 2019; i++) {
                    d3.select("." + d.replace(/\s/g, '_') + i)
                        .attr("stroke", "black")
                } 
            })
            .on("mouseout", function(d) {
                // Restores everything
                d3.select(".rect"+d)
                    .attr("stroke", "none");
                d3.select(".text"+d)
                    .attr("text-decoration", "none");
                d3.select("." + d + 2019)
                        .attr("stroke", "null");
                for (i = 1950; i <= 2019; i++) {
                    d3.select("." + d.replace(/\s/g, '_') + 2019)
                        .attr("stroke", "none");
                } 
            }); */
    }
        
    // Finds the points achieved by a driver season by season
    function findPointsAchieved(data, surname, name) {
        // Groups all the results by pilot
        groupedResults = d3.nest()
            .key(function(d) {
                return d.surname + "_" + d.name;
            })
            .entries(data);

        // Finds the results of the selected pilot
        relevantResults = [];
        for (i = 0; i < groupedResults.length; i++) {
            driverResults = groupedResults[i];
            if (driverResults.key == surname + "_" + name) {
                relevantResults = driverResults.values;
            }
        }
        
        // Groups the relevant results by year/constructor and finds the total number of points by year/constructor
        relevantResults = d3.nest()
            .key(function(d) {
                return d.year;
            })
            .key(function(d) {
                return d.constructor.replace(/\s/g, '_');
            })
            .rollup(function(d) {
                return {
                    totalPoints: d3.sum(d, function(g) {
                        return g.points;
                    })
                }
             })
            .entries(relevantResults);
        
        console.log(relevantResults);   
        return relevantResults;
    }
        
                       
    drawTitle();
    </script>
    </body>
</html>