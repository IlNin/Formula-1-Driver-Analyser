<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html;charset=utf-8">
        <title>Formula 1 Driver Analyser</title>
        <script type="text/javascript" src="d3.js" charset="utf-8"></script>
        <link rel="stylesheet" type="text/css" href="style.css"/>
	</head>
    
    <body>
    <script charset="utf-8">  
    // Dimensions
    var margins = {top: 20, right: 10, bottom: 40, left: 45};
    var container_dimensions = {width: 550, height: 250}; 
    var chart_dimensions = {
        width: container_dimensions.width - margins.left - margins.right,
        height: container_dimensions.height - margins.top - margins.bottom
    };
    var small_container_dimensions = {width: 350, height: 250};
    var small_chart_dimensions = {
        width: small_container_dimensions.width - margins.left - margins.right,
        height: small_container_dimensions.height - margins.top - margins.bottom
    };
    var barSize = 30;
    var legend_width = 119;
    
    // Divs
    var wrapper;
    var bottomWrapper;
    var barSvg; // Svg for the points bars
    var svgLegend;
    
    // User inputs
    var showActiveDrivers = true; // Flag that indicates to show only active drivers
    var showTotalPoints = true; // Flag that indicates to show the total points instead of the average per race
    var showWinsInRaces = true; // Flag that indicates to show the wins in races instead of qualifying
    
    // Drivers data
    var activeDrivers = []; // List of drivers loaded by the data that are active
    var retiredDrivers = []; // List of drivers loaded by the data that are retired
    var selectedDriver = "";
    
    // Avg line parameters
    var barsClicked = []; // List of bars clicked in the total points chart
    var nBarsClicked = 0;
    var cumulativePoints = 0;
    
    // Draws the title screen above the charts
    function drawTitle() {
        // Creates the wrapper div that contains the div 'title'
        aboveWrapper = document.createElement('div');
        aboveWrapper.id = "abovewrapper";
        aboveWrapper.onmouseover = function() {
            writeOnAbout(0);
        }
        document.body.appendChild(aboveWrapper);
        
        // Creates the div 'title' which contains text, selections and buttons
        title = document.createElement('div');
        title.id = "title";
        title.innerHTML = "<h2>Formula 1 Driver Analyser</h2>";
        aboveWrapper.appendChild(title);   
        
        // Creates the div 'menu' which allows the user to select a driver
        menu = document.createElement('div');
        menu.id = "menu";
        aboveWrapper.appendChild(menu);
        
        // Adds radios button in order to distinguish between active and retired drivers
        menu.innerHTML += "Choose between drivers that are: ";
        activeButton = document.createElement('input');
        activeButton.type = 'radio';
        activeButton.name = 'drivers';
        activeButton.id = 'active-drivers';
        activeButton.value = "active";
        label = document.createElement('label');
        label.innerHTML = "Active";
        menu.appendChild(activeButton);
        menu.appendChild(label);
        menu.innerHTML += "   ";
        
        retiredButton = document.createElement('input');
        retiredButton.type = 'radio';
        retiredButton.name = 'drivers';
        retiredButton.id = 'retired-drivers';
        retiredButton.value = "retired";
        label = document.createElement('label');
        label.innerHTML = "Retired";
        menu.appendChild(retiredButton);
        menu.appendChild(label);
        menu.innerHTML += "<br>";
        
        // Creates a selection for the drivers with a default option, and adds it to 'title'
        menu.innerHTML += "Please select a driver: ";

        selectDriver = document.createElement('select');
        selectDriver.id = "select-driver";
        selectDriver.style.width = "150px";
        defaultDriverOption = document.createElement('option');
        defaultDriverOption.value = 0;
        defaultDriverOption.innerHTML = "- DRIVER -";
        selectDriver.appendChild(defaultDriverOption);
        menu.appendChild(selectDriver);
        menu.innerHTML += " ";
        
         // Creates the search button, makes it disabled and adds it to 'title'
        searchButton = document.createElement('button');
        searchButton.id = "search";
        searchButton.innerHTML = "Search data!";
        searchButton.disabled = true;
        menu.appendChild(searchButton);
        
        about = document.createElement('div');
        about.id = "about";
        aboveWrapper.appendChild(about);
        writeOnAbout(0);
        
        document.getElementById("active-drivers").checked = true; 
        loadData();
    }
    
    // Loads the data from the csv file
    function loadData() {
        d3.queue()
            .defer(d3.csv, "results.csv")
            .defer(d3.csv, "qualifying.csv")
            .await(function(error, data, data2) {
                // Prints the error in case something goes wrong
                if (error) {
                    console.log(error);
                }
                // Everything goes ok!
                else {
                    // Sort all the drivers in two list: one for the recent ones, the other for the past drivers
                    activeDrivers = []; // Will Contain all active drivers inside the csv file
                    retiredDrivers = []; // Will contain all retired drivers inside the csv file
                    data.forEach(function(d) { // Cycles through the data
                        d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                        d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                        driver = d.surname + "_" + d.name;
                        if (d.year == 2019 && !activeDrivers.includes(driver)) {
                            activeDrivers.push(driver);
                            index = retiredDrivers.indexOf(driver);
                            if (index) {
                                retiredDrivers.splice(index, 1);
                            }
                        }
                        else if (d.year >= 1994 && !retiredDrivers.includes(driver) && !activeDrivers.includes(driver)) {
                            retiredDrivers.push(driver);
                        }
                    });
                    
                    data2.forEach(function(d) { // Cycles through the qualifying data
                        d.surname = d.surname.replace(/[\s.']/g, '_'); // Removes eventual spaces in the surnames
                        d.name = d.name.replace(/[\s.']/g, '_'); // Removes eventual spaces in the names
                    });
                    
                    // Sort all drivers in alphabetical order
                    activeDrivers.sort(function(a, b) {
                        if (a < b) { 
                            return -1; 
                        }
                        if (a > b) { 
                            return 1; 
                        }
                        return 0;
                    });
                    retiredDrivers.sort(function(a, b){
                        if (a < b) { 
                            return -1; 
                        }
                        if (a > b) {
                            return 1; 
                        }
                        return 0;
                    });
                
                    addDriversToTitle(); // Adds the events to the user's selections in the title now that the data is loaded
                    enableInputsToTitle(data, data2);
                }
            });
    }
    
    // Adds the correct list of drivers to the selection
    function addDriversToTitle() {
        if (showActiveDrivers) {
            for (i = 0; i < activeDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = activeDrivers[i].replace(/_/g, ' ');
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
        else {
            for (i = 0; i < retiredDrivers.length; i++) {
                newDriverOption = document.createElement('option'); // Makes the new season a selectable option 
                newDriverOption.value = i+1;
                newDriverOption.innerHTML = retiredDrivers[i].replace(/_/g, ' ');
                document.getElementById("select-driver").appendChild(newDriverOption);
            }
        }
    }
    
    // Adds events to the interactions of the user with the title screen
    function enableInputsToTitle(data, data2) {
        document.getElementById("active-drivers").onclick = function() {
            showActiveDrivers = true;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("retired-drivers").onclick = function() {
            showActiveDrivers = false;
            document.getElementById("search").disabled = true; // Disables the search button
            document.getElementById("select-driver").value = 0; // Restore the driver selector to the default option
            options = document.getElementById("select-driver").options.length; // Removes all options inside the selector bar the default one
            for (i = options-1; i > 0; i--) {
                document.getElementById("select-driver").options[i] = null;
            }
            addDriversToTitle();
        }
        document.getElementById("select-driver").onchange = function() { 
            if (document.getElementById("select-driver").value > 0) {  // A valid driver is selected: enables search button
                document.getElementById("search").disabled = false;
            }
            else { // Default option selected: disables search button
                document.getElementById("search").disabled = true;
            }
        }
        search.onclick = function() { // Checks if the user clicks the search button
            value = document.getElementById("select-driver").value;
            if (showActiveDrivers) {
                selectedDriver = activeDrivers[value-1];
                initializeChartsLayout(data, data2);
            }
            else {
                selectedDriver = retiredDrivers[value-1];
                initializeChartsLayout(data, data2);
            }
        }    
    }
    
    // Prepares the layouts of the charts before plotting data on them
    function initializeChartsLayout(data, data2) {
        // Removes the previous layout and restores global variables
        if (document.body.contains(wrapper)) {
            wrapper.remove();
            bottomWrapper.remove();
            document.getElementById("selecteddriver").remove();
        }
        showTotalPoints = true;
        showWinsInRaces = true;
        
        // Appends the div with the name of the driver selected
        driverSelectedDiv = document.createElement('div');
        driverSelectedDiv.id = "selecteddriver";
        driverSelectedDiv.innerHTML = "<b>" + selectedDriver.replace(/_/g, ' ') + "</b";
        document.body.appendChild(driverSelectedDiv);
        
        // Initializes the middle wrapper
        wrapper = document.createElement('div');
        wrapper.id = "middlewrapper";
        wrapper.innerHTML += "<br>";
        document.body.append(wrapper);
        
        // Prepares all the layouts in the middle wrapper
        preparePointsAchieved(data);    
        prepareComparisons(data, data2);
        
        // Initializes the bottom wrapper
        bottomWrapper = document.createElement('div');
        bottomWrapper.id = "bottomwrapper";
        bottomWrapper.innerHTML += "<br>";
        document.body.append(bottomWrapper);
        
        // Prepares all the layouts in the bottom wrapper
        prepareDNF(data);
    }
    
    // Prepares the layout for the points achieved chart
    function preparePointsAchieved(data) { 
        // Initializes the div that contains the svg area for the points bars    
        svgDiv = document.createElement('div');
        svgDiv.id = "bargraph";
        svgDiv.innerHTML = "<b>Points Per Season</b><br>";
        svgDiv.onmouseover = function() {
            writeOnAbout(1);
        }
        wrapper.append(svgDiv); 
        
        // Initalizes an empty svg for the points bars
        barSvg = d3.select('#bargraph')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Adds radios button in order to switch between total points and average points per race
        optionsDiv = document.createElement('div');
        svgDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        totalButton = document.createElement('input');
        totalButton.type = 'radio';
        totalButton.name = 'points';
        totalButton.id = 'total-points';
        totalButton.value = "total";
        label = document.createElement('label');
        label.innerHTML = "Total Points";
        optionsDiv.appendChild(totalButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";

        averageButton = document.createElement('input');
        averageButton.type = 'radio';
        averageButton.name = 'points';
        averageButton.id = 'average-points';
        averageButton.value = "average";
        label = document.createElement('label');
        label.innerHTML = "Average Points Per Race";
        optionsDiv.appendChild(averageButton);
        optionsDiv.appendChild(label);
        document.getElementById("total-points").checked = true;
        
        document.getElementById('total-points').onclick = function() {
            showTotalPoints = true;
            plotPointsAchieved(data);
        }
        document.getElementById('average-points').onclick = function() {
            showTotalPoints = false;
            plotPointsAchieved(data);
        }
      
        // Initializes the div for the points bar graph legend
        svgLegendDiv = document.createElement('div');
        svgLegendDiv.innerHTML = "Legend Table<br>";
        svgLegendDiv.id = "legendtable";
        svgLegendDiv.onmouseover = function() {
            writeOnAbout(1);
        }
        wrapper.append(svgLegendDiv);
        
        // Initializes the empty svg for the bar graph legend
        svgLegend = d3.select('#legendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","legendtable");
        
        // Plots the bar graph that shows the points achieved by the driver season by season
        plotPointsAchieved(data);
    }
          
    // Plot a bar graph that shows the points achieved by the driver season by season
    function plotPointsAchieved(data) {
        // Erase previous data
        barSvg.selectAll('*').remove();
        barsClicked = []; 
        nBarsClicked = 0;
        cumulativePoints = 0
    
        // Finds the relevant data to plot
        relevantData = findPointsAchieved(data);
  
        // Initializes the x scale
        minYear = relevantData[0].key;
        maxYear = relevantData[relevantData.length-1].key;
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key;
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        // Initializes the y scale
        maxPoints = 0;
        for (i = 0; i < relevantData.length; i++) {
            points = 0;
            for (j = 0; j < relevantData[i].values.length; j++) {
                points += relevantData[i].values[j].value.totalPoints;
            }
            if (points > maxPoints) {
                maxPoints = points;
            }
        }
        if (maxPoints == 0) {
            maxPoints = 1;
        }
        y = d3.scaleLinear()
            .domain([maxPoints, 0])
            .range([0, chart_dimensions.height]);
        
        // Initializes the colors
        colors = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yAxis = d3.axisLeft(y).ticks().tickFormat(d3.format("d"));
        
        // Appends the x axis
        barSvg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+(chart_dimensions.height)+")")
            .call(xAxis);
        barSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the y axis
        barSvg.append("g")
            .attr("class","y_axis")
            .call(yAxis)
        barSvg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.2em")
            .style("text-anchor","end")
            .text(function() {
                if (showTotalPoints) {
                    return "Total Points";
                }
                else {
                    return "Avg. Points Per Race";
                }
            });
       
        // Draws the bars
        constructors = []; // Keeps a list of constructors for the legend
        for (i = 0; i < relevantData.length; i++) { // Cycles through the years
            year = relevantData[i].key;
            for (j = 0; j < relevantData[i].values.length; j++) { // Cycles through the constructors per year
                constructor = relevantData[i].values[j].key;
                
                // Behind the scenes stuff
                if (!constructors.includes(constructor) && relevantData[i].values[j].value.totalPoints > 0) { // Filters out constructors with zero points
                    constructors.push(constructor);
                } 
                if (j > 0) { // Check if there's a bar below (aka a constructor change in the season) and if so, it takes its measures
                    barBelowY = relevantData[i].values[j-1].value.totalPoints;
                }
                
                // Draws the bar
                bar = barSvg.selectAll("bar")
                    .data([relevantData[i].values[j].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", constructor + year)
                        .style("fill", function(d) {
                            return colors(constructor);
                        })
                        .style("opacity", function(d) {
                            if (d.totalPoints == 0) {
                                return 0; }
                            else {
                                return 1;
                            }
                        })
                        .attr("stroke-width", 3)
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", y(0))
                        .attr("height", 0);
                        
                // Handles the animations
                drawInvisibleBar = true; // Flag that indicates to draw an invisible bar in case there are no points (so that labels can still appear)
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) { 
                        if (j > 0) { // If there's a bar below, stack the new bar above it
                            return y(d.totalPoints + barBelowY);
                        }
                        if (d.totalPoints == 0) { // Check if to draw an invisible bar
                            for (z = j; z < relevantData[i].values.length; z++) { // Checks if the driver got points with other constructors in that year
                                if (relevantData[i].values[z].value.totalPoints > 0) {
                                    drawInvisibleBar = false; // Can't draw a bar since there's will be a visible bar later for this year
                                }
                            }
                            if (drawInvisibleBar) {
                                return y(maxPoints);
                            }
                        }
                        return y(d.totalPoints); 
                    })
                    .attr("height", function(d) { 
                        if (j > 0) {
                            return y(barBelowY) - y(d.totalPoints+barBelowY);
                        }
                        if (d.totalPoints == 0 && drawInvisibleBar) { // Invisible bar
                            return chart_dimensions.height - y(maxPoints);
                        }
                        return chart_dimensions.height - y(d.totalPoints); 
                    });
                
                // Handles inputs                 
                bar.on("mouseover", function(d) {  
                    if (nBarsClicked == 0) {
                        d3.select(this)
                            .style("stroke", "black");
                    }
                    // Draws a label with information about the bar
                    coords = d3.mouse(this);
                    classLength = d3.select(this).attr("class").length;
                    constructor = d3.select(this).attr("class").substring(0, classLength-4);
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    text = "[Points: " + d.totalPoints.toFixed(2) + ", Constructor: " + constructor.replace(/_/g, ' ') + "]";
                    drawOnMouseOverLabel(coords, barSvg, text, colors(constructor), year, minYear, maxYear);
                });
                   
                bar.on("mouseout", function(d) {      
                    if (nBarsClicked == 0) {
                        d3.select(this)
                            .style("stroke", "none");
                    }
                    // Removes the label with information about the bar
                    d3.select(".rect_label")
                        .remove();
                });
                
                bar.on("click", function(d) {
                    // Selects the bar clicked, and also the other bars in the same year
                    year = d3.select(this).attr("class").substring(classLength-4, classLength);
                    selection = d3.selectAll("[class$='" + year + "']");
                    
                    // Calculates the total number of points to add/remove to the average
                    points = selection.data();
                    totalPoints = 0;
                    for (i = 0; i < points.length; i++) {
                        totalPoints += points[i].totalPoints;
                    }
                    
                    // Gives them a stroke if they have been selected for the first time, otherwise removes the previous stroke
                    add = true; // Flag that indicates if to increase or decrease the total number of points across the season 
                    selection
                        .style("stroke", function(d) {
                            currentClass = d3.select(this).attr("class");
                            if (!barsClicked.includes(currentClass)) {
                                barsClicked.push(currentClass);
                                return "black";
                            }
                            else {
                                add = false;
                                index = barsClicked.indexOf(currentClass);
                                barsClicked.splice(index, 1);
                                return "none";
                            }
                        })
                        .style("opacity", function(d) {
                            if (d3.select(this).style("opacity") == 0) {
                                return 0.1;
                            }
                            else if (d3.select(this).style("opacity") == 0.1) {
                                return 0;
                            }
                       });
                    
                    // Calculates the total number of points to add/remove to the cumulative points across the seasons
                    points = selection.data();
                    if (add) {
                        nBarsClicked += 1;
                        for (i = 0; i < points.length; i++) {
                            cumulativePoints += points[i].totalPoints;
                        }
                    }
                    else {
                        nBarsClicked -= 1;
                        for (i = 0; i < points.length; i++) {
                            cumulativePoints -= points[i].totalPoints;
                        }
                    }
                    
                    /* DEBUG
                    console.log("[" + cumulativePoints + ", " + nBarsClicked + "]"); */
                    
                    // Adds/update a mean line in the total points bar chart
                    d3.select(".mean").remove()
                    
                    if (nBarsClicked > 0) {
                        mean = cumulativePoints/nBarsClicked;
                        barSvg.append("line")
                            .attr("class", "mean")
                            .attr("x1", 0)
                            .attr("y1", y(mean))
                            .attr("x2", chart_dimensions.width)
                            .attr("y2", y(mean))
                            .style("stroke", "red")
                            .style("stroke-width", 3)
                            .on("mouseover", function(d) {
                                coords = d3.mouse(this);
                                text = "[Mean: " + mean.toFixed(2) + ", Sum: " + cumulativePoints.toFixed(2) + "] ";
                                drawOnMouseOverLabel(coords, barSvg, text, "red", year, minYear, maxYear);
                            })
                            .on("mouseout", function(d) {
                                d3.select(".rect_label")
                                    .remove();
                            });
                    }
                });
            }        
        }
        
        // Draws the legend for the graph
        drawPointsAchievedLegend(constructors);      
    }
        
    // Draws the legend for the points bar graph
    function drawPointsAchievedLegend(constructors) {
        // Erase previous data
        svgLegend.selectAll('*').remove();
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgLegend.selectAll("legend")
            .data(constructors)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*10)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colors(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
            
        // Add input events to the legend
        legend
            .on("mouseover", function(d) {
                // Highlights the entry in the legend and outlines the right bars
                d3.select(".rect"+d)
                    .attr("stroke", "black");
                d3.select(".text"+d)
                    .attr("text-decoration", "underline overline");
                if (nBarsClicked == 0) {
                    barSvg.selectAll("[class*=" + d + "]")
                        .style("stroke", "black");        
                }
            })
            .on("mouseout", function(d) {
                // Restores everything
                d3.select(".rect"+d)
                    .attr("stroke", "none");
                d3.select(".text"+d)
                    .attr("text-decoration", "none");
                if (nBarsClicked == 0) {
                    barSvg.selectAll("[class*=" + d + "]")
                        .style("stroke", "none"); 
                }
            });
    }
    
    // Prepares the layout for the comparisons with teammates chart
    function prepareComparisons(data, data2) {
        // Initializes the div that contains the svg area for the comparisons   
        svgCmpDiv = document.createElement('div');
        svgCmpDiv.id = "comparisons";
        svgCmpDiv.innerHTML = "<b>Wins/Losses Against Teammates</b><br>";
        svgCmpDiv.onmouseover = function() {
            writeOnAbout(2);
        }
        wrapper.append(svgCmpDiv); 
        
        // Initalizes an empty svg for the points bars
        cmpSvg = d3.select('#comparisons')
            .append('svg')
                .attr("width", container_dimensions.width)
                .attr("height", container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
        
        // Adds radios button in order to switch between total points and average points per race
        optionsDiv = document.createElement('div');
        svgCmpDiv.appendChild(optionsDiv);
        optionsDiv.innerHTML = "Show: ";
        winsRacesButton = document.createElement('input');
        winsRacesButton.type = 'radio';
        winsRacesButton.name = 'races-or-quali';
        winsRacesButton.id = 'show-races';
        winsRacesButton.value = "races";
        label = document.createElement('label');
        label.innerHTML = "Wins In Races";
        optionsDiv.appendChild(winsRacesButton);
        optionsDiv.appendChild(label);
        optionsDiv.innerHTML += "   ";

        winsQualiButton = document.createElement('input');
        winsQualiButton.type = 'radio';
        winsQualiButton.name = 'races-or-quali';
        winsQualiButton.id = 'show-quali';
        winsQualiButton.value = "quali";
        label = document.createElement('label');
        label.innerHTML = "Wins In Qualifying";
        optionsDiv.appendChild(winsQualiButton);
        optionsDiv.appendChild(label);
        document.getElementById("show-races").checked = true;
        
         document.getElementById('show-races').onclick = function() {
            showWinsInRaces = true;
            plotComparisons(data, data2);
        }
        document.getElementById('show-quali').onclick = function() {
            showWinsInRaces = false;
            plotComparisons(data, data2);
        }
        
        // Initializes the div for the points bar graph legend
        svgCmpLegendDiv = document.createElement('div');
        svgCmpLegendDiv.innerHTML = "Legend Table<br>";
        svgCmpLegendDiv.id = "cmplegendtable";
        svgCmpLegendDiv.onmouseover = function() {
            writeOnAbout(2);
        }
        wrapper.append(svgCmpLegendDiv);
        
        // Initializes the empty svg for the bar graph legend
        svgCmpLegend = d3.select('#cmplegendtable')
            .append('svg')
                .attr("width", legend_width)
                .attr("height", container_dimensions.height)
                // .style("background-color", "red")
                .append("g")
                    .attr("transform", "translate(" + 0 + "," + margins.top/4 + ")")
                    .attr("id","cmplegendtable");
        
        // Plots a bar graph that shows the comparisons with teammates
        plotComparisons(data, data2);
    }
    
    // Plots a bar graph that shows the comparisons with teammates
    function plotComparisons(data, data2) {
        // Erase previous data
        cmpSvg.selectAll('*').remove();
        
        // Finds the relevant data to plot
        relevantData = [];
        if (showWinsInRaces) {
            relevantData = findWinsAgainstTeammates(data);
        }
        else {
            relevantData = findWinsAgainstTeammates(data2);
        }
        
        // Initializes the x scale and finds the range of seasons
        minYear = relevantData[0].key.substring(0, 4);
        maxYear = relevantData[relevantData.length-1].key.substring(0, 4);
        x = d3.scaleBand()
            .domain(relevantData.map(function(d) {
                return d.key.substring(0, 4);
            }))
            .range([0, chart_dimensions.width])
            .padding(.5);
        
        // Initializes the y scale and finds the biggest number of wins/losses in order to set up the scale
        maxWins = 0;
        previousYear = 0;
        topWins = 0;
        bottomWins = 0;
        for (i = 0; i < relevantData.length; i++) { // Cycles through the years
            year = relevantData[i].key.substring(0, 4); // Gets current year
            if (year != previousYear) { // If it is a new year (meaning no new teammates in the same year) the number of wins is resetted.
                previousYear = year;
                topWins = 0;
                bottomWins = 0;
            }
            topWins += relevantData[i].value.selectedDriverWins;
            if (topWins > maxWins) {
                maxWins = topWins;
            }
            bottomWins += relevantData[i].value.teammateWins;
            if (bottomWins > maxWins) {
                maxWins = bottomWins;
            }
        }
        if (maxWins == 0) {
            maxWins = 1;
        }
        yTop = d3.scaleLinear()
            .domain([maxWins, 0])
            .range([0, chart_dimensions.height/2]);
        
        yBottom = d3.scaleLinear()
            .domain([0, maxWins])
            .range([0, chart_dimensions.height/2]);
        
        // Initializes the colors
        colorsTeammates = d3.scaleOrdinal(d3.schemeCategory20);
        
        // Initializes the axis
        xAxis = d3.axisBottom(x).ticks().tickFormat(d3.format("d"));
        yTopAxis = d3.axisLeft(yTop).ticks(4).tickFormat(d3.format("d"));
        yBottomAxis = d3.axisLeft(yBottom).ticks(4).tickFormat(d3.format("d"));
        
        // Appends the x axis
        cmpSvg.append("g")
            .attr("class","x_axis")
            .attr("transform", "translate(0,"+ (chart_dimensions.height) +")")
            .call(xAxis);
        cmpSvg.append("text")
            .attr("class","label")
            .attr("x", chart_dimensions.width)
            .attr("y", chart_dimensions.height+(margins.bottom-10))
            .style("text-anchor","end")
            .text("Seasons");
        
        // Appends the top y axis
        cmpSvg.append("g")
            .attr("class","yTop_axis")
            .call(yTopAxis)
        cmpSvg.append("text")
            .attr("class","label")
            .attr("transform","rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.5em")
            .style("text-anchor","end")
            .style("font", "12px times")
            .text(function(d) {
                if (showWinsInRaces) {
                    return "Wins In Races";
                }
                else {
                    return "Wins In Qualy";
                }
            });
        
        // Appends the bottom y axis
        cmpSvg.append("g")
            .attr("transform", "translate(0," + (chart_dimensions.height)/2 + ")")
            .attr("class","yBottom_axis")
            .call(yBottomAxis); 
        cmpSvg.append("text")
            .attr("class","label")
            .attr("transform", "translate(0," + (chart_dimensions.height) + ")" + "rotate(-90)")
            .attr("y", 6)
            .attr("dy","-2.5em")
            .style("text-anchor","start")
            .style("font", "12px times")
            .text(function(d) {
                if (showWinsInRaces) {
                    return "Losses In Races";
                }
                else {
                    return "Losses In Qualy";
                }
            });
        
        // Plot the data
        teammates = []; // Contains the list of drivers involved in the comparison
        teammates.push(selectedDriver);
        previousYear = 0; // Previous year found while cycling through the data
        barBelowTopY = 0; // Size of the bar on the top Y if there's one below the current one
        barAboveBottomY = 0; // Size of the bar on the bottom Y if there's one above the current one
        for (i = 0; i < relevantData.length; i++) {
            year = relevantData[i].key.substring(0, 4);
            
            // Check if there are more teammates in the same year (aka if there are already bars in place)
            if (year != previousYear) {
                previousYear = year;
                barBelowTopY = 0;
                barAboveBottomY = 0;
            }
            else {
                barBelowTopY += relevantData[i-1].value.selectedDriverWins;
                barAboveBottomY += relevantData[i-1].value.teammateWins;
            }
            
            // Refresh the list of teammates
            teammate = relevantData[i].key.substring(5, relevantData[i].key.length);
            if (!teammates.includes(teammate) && relevantData[i].value.teammateWins > 0) {
                teammates.push(teammate);
            }
            
            // Plot selected driver and teammate
            for (j = 0; j < 2; j++) {           
                bar = cmpSvg.selectAll("bar")
                    .data([relevantData[i].value]) // The [ ] parenthesis turn the object in an array
                    .enter()
                    .append("rect")
                        .attr("class", function(d) {
                            if (j == 0) { // Index 0 means this is the selected driver
                                return "rect0" + relevantData[i].key;
                            }
                            else { // Index 1 means this is the teammate
                                return "rect1" + relevantData[i].key;
                            }
                        })
                        .style("fill", function(d) {
                            if (j == 0) {
                                return colorsTeammates(selectedDriver);
                            }
                            else {
                                return colorsTeammates(teammate);
                            }
                        })
                        .style("stroke", "white")
                        .style("stroke-width", 1)
                        .attr("x", x(year)) 
                        .attr("width", x.bandwidth)
                        .attr("y", yTop(0))
                        .attr("height", 0);
                
                // Handles animation
                bar.transition()
                    .duration(2000)
                    .attr("y", function(d) {
                        if (j == 0) {
                            return yTop(d.selectedDriverWins + barBelowTopY);
                        }
                        else {
                            return yTop(-barAboveBottomY);
                        }
                    })
                    .attr("height", function(d) {
                        if (j == 0) {
                            if (barBelowTopY == 0) {
                                return chart_dimensions.height/2 - yTop(d.selectedDriverWins);
                            }
                            else {
                                return yTop(barBelowTopY) - yTop(d.selectedDriverWins + barBelowTopY);
                            }
                        }
                        else {
                            return yBottom(d.teammateWins);
                       }
                    });
                    
              
                // Handles inputs
                bar.on("mouseover", function(d) {
                    // Outlines the bar
                    d3.select(this)
                        .style("stroke", "black");
                
                    // Draws a label with information about the bar
                    coords = d3.mouse(this);
                    id = d3.select(this).attr("class");
                    flagTop = id.substring(4, 5);
                    year = id.substring(5, 9);
                    teammate = id.substring(10, id.length);
                    text = "";
                    color = "";
                    if (flagTop == "0") {     
                        text = "[Wins against " + teammate.replace(/_/g, ' ') + ": " + d.selectedDriverWins + "] ";
                        color = colorsTeammates(selectedDriver);
                    }
                    else {
                        text = "[Losses against " + teammate.replace(/_/g, ' ') + ": " + d.teammateWins + "] ";
                        color = colorsTeammates(teammate);
                    }
                    drawOnMouseOverLabel(coords, cmpSvg, text, color, year, minYear, maxYear);
                });
                
                bar.on("mouseout", function(d) {
                    // Restores everything
                    d3.select(this)
                        .style("stroke", "white");
                    d3.select(".rect_label")
                        .remove();
                });             
            }
        }  

        // Draws the legend
        drawComparisonLegend(data, data2, teammates);
    }
    
    // Draws the legend for the comparison graph
    function drawComparisonLegend(data, data2, teammates) {
        // Erase previous data
        svgCmpLegend.selectAll('*').remove();
        
        // Prepares the space/layout for the legend
        sizeSquare = 10;
        legend = svgCmpLegend.selectAll("legend")
            .data(teammates)
            .enter()
            .append("g")
            .attr("class", "legend")
			.attr("transform", function(d,i){
                return "translate(0,"+(i*sizeSquare+i*5)+")";
            });
        
        // Draws the small colored rectangles
        legend.append("rect")
			.attr("width", sizeSquare)
			.attr("height", sizeSquare)
            .attr("class", function(d) {
                return "rect"+d;
            })
			.style("fill", function(d){
                return colorsTeammates(d);
			});
            
        // Writes the text near the small colored rectangles
        legend.append("text")
            .attr("class", function(d) {
                return "text"+d;
            })
            .attr("x", sizeSquare+5)
            .attr("y", sizeSquare/2)
            .attr("dy", ".35em")
            .style("font", "12px times")
            .text(function(d) {
                return d.replace(/_/g, ' ');
            });
        
        // Add input events to the legend
        legend
            .on("mouseover", function(d) {
                // Highlights the entry in the legend and outlines the right bars
                if (activeDrivers.includes(d) || retiredDrivers.includes(d)) {
                    d3.select(".rect"+d)
                        .attr("stroke", "black");
                    d3.select(".text"+d)
                        .attr("text-decoration", "underline overline");    
                }
                if (d == selectedDriver) {
                    cmpSvg.selectAll("[class^=rect0]")
                        .style("stroke", "black");
                }
                else {
                    cmpSvg.selectAll("[class^=rect1][class$=" + d + "]")
                        .style("stroke", "black");
                }
            })
            .on("mouseout", function(d) {
                // Restores everything
                d3.select(".rect"+d)
                    .attr("stroke", "none");
                d3.select(".text"+d)
                    .attr("text-decoration", "none");
                cmpSvg.selectAll("[class^=rect]")
                    .style("stroke", "white")
            })
            .on("click", function(d) {
                if (activeDrivers.includes(d) || retiredDrivers.includes(d)) {
                    selectedDriver = d;
                    initializeChartsLayout(data, data2);
                }
            });
    }
    
    // Prepares the layout for the chart that displays the causes of DNFs
    function prepareDNF(data) {
        // Initializes the div that contains the svg area for the comparisons   
        svgDNFDiv = document.createElement('div');
        svgDNFDiv.id = "dnf";
        svgDNFDiv.innerHTML = "<b>Causes of DNFs</b><br>";
        svgDNFDiv.onmouseover = function() {
            writeOnAbout(3);
        }
        bottomWrapper.append(svgDNFDiv); 
        
        // Initalizes an empty svg for the points bars
        dnfSvg = d3.select('#dnf')
            .append('svg')
                .attr("width", small_container_dimensions.width)
                .attr("height", small_container_dimensions.height)
                //.style("background-color", "red")
            .append("g")
                .attr("transform", "translate(" + margins.left + "," + margins.top + ")")
                .attr("id", "bargraph");
    }
    
    // Draws on the svg a label near the mouse location
    function drawOnMouseOverLabel(coords, svg, text, color, place, minPlace, maxPlace) {
        // Each text label will be inside a black outlined rect in g
        g = svg.append("g") 
            .attr("class", "rect_label");
        rect = g.append('rect')
            .attr("width", text.length*7)
            .attr("height", 20)
            .attr("stroke", "black")
            .style("fill", "white"); 
                            
        // Checks if to place the information on the right or on the left of the mouse location
        if (parseInt(place) <= (parseInt(minPlace)+ parseInt(maxPlace))/2) {
            rect.attr("x", coords[0]+6)
                .attr("y", coords[1]-30);
            g.append('text')
                .attr("x", coords[0]+10)
                .attr("y", coords[1]-15)
                .attr("fill", color)
                .text(text);
        }
        else {
            rect.attr("x", coords[0]-250)
                .attr("y", coords[1]-30);
            g.append('text')
                .attr("x", coords[0]-246)
                .attr("y", coords[1]-15)
                .attr("fill", color)
                .text(text);      
        }
    }                        
    
    // Writes the right text on the upper right section of the application
    function writeOnAbout(index) {
        if (index == 0) {
            about.innerHTML = "This is a VA application that lets the user find stats on Formula 1 drivers, so that they can gain a better knowledge of their skill and place in the sport.<br>";
            about.innerHTML += "<i>- Made by Luca Sannino as a project for Visual Analytics 2021 -</i>";
        }
        else if (index == 1) {
            about.innerHTML = "This bar chart shows the total points achieved by the selected driver per season. The user can also switch to the avg. points per race (per season) and interact with the bars by clicking them to calculate new averages on-the-fly.";
        }
        else if (index == 2) {
            about.innerHTML = "This bar charts shows how many times the selected driver has placed better than their teammates across the seasons. The user can also switch between race and qualifying results and interact with the legend to select a new driver.";
        }
        else {
            about.innerHTML = index;
        }
    }
        
    // Finds the points achieved by a driver season by season
    function findPointsAchieved(data) {
        // Groups all the results by pilot
        groupedResults = d3.nest()
            .key(function(d) {
                return d.surname + "_" + d.name;
            })
            .entries(data);

        console.log(groupedResults);
        // Finds the results of the selected pilot
        relevantResults = [];
        for (i = 0; i < groupedResults.length; i++) {
            driverResults = groupedResults[i];
            if (driverResults.key == selectedDriver) {
                relevantResults = driverResults.values;
            }
        }
        
        // Groups the relevant results by year/constructor and finds the total number of points by year/constructor
        if (showTotalPoints) {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.sum(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        // Groups the relevant results by year/constructor and finds the average number of points per race by year/constructor
        else {
            relevantResults = d3.nest()
                .key(function(d) {
                    return d.year;
                })
                .key(function(d) {
                    return d.constructor.replace(/\s/g, '_');
                })
                .rollup(function(d) {
                    return {
                        totalPoints: d3.mean(d, function(g) {
                            return g.points;
                        })
                    }
                })
                .entries(relevantResults);
        }
        
        /* DEBUG
        console.log(relevantResults); */
        
        return relevantResults;
    }
     
    // Finds how many times the current driver has won against his teammates
    function findWinsAgainstTeammates(data) {
        // Groups all the results by race and constructor
        groupedResults = d3.nest()
            .key(function(d) {
                return d.year + "_" + d.round + "_" + d.grandprix + "_" + d.constructor;
            })
            .entries(data);
        
        // Extracts the results of the selected driver and his teammate (or even teammates) for each race
        relevantResults = [];
        newTuples = [];
        for (i = 0; i < groupedResults.length; i++) {
            constructorResults = groupedResults[i].values;
            selectedDriverPosition = 0;
            name = "";
            surname = "";
            findTeammates = false;
            for (j = 0; j < constructorResults.length; j++) {
                if ((constructorResults[j].surname + "_" + constructorResults[j].name) == selectedDriver && findTeammates == false) {
                    relevantResults.push(constructorResults);
                    findTeammates = true;
                    selectedDriverPosition = constructorResults[j].position;
                    name = constructorResults[j].name;
                    surname = constructorResults[j].surname;
                    j = -1;
                }
                else if ((constructorResults[j].surname + "_" + constructorResults[j].name) != selectedDriver && findTeammates == true) {
                    newTuple = {
                        year: constructorResults[j].year,
                        round: constructorResults[j].round,
                        grandprix: constructorResults[j].grandprix,
                        constructor: constructorResults[j].constructor,
                        selectedDriverSurname: surname,
                        selectedDriverName: name,
                        selectedDriverPosition: selectedDriverPosition,
                        teammateSurname: constructorResults[j].surname,
                        teammateName: constructorResults[j].name,
                        teammatePosition: constructorResults[j].position
                        }
                    newTuples.push(newTuple);
                }
            }
        }
        
        // Transforms the data in the final form used by the chart
        relevantData = d3.nest()
            .key(function(d) {
                return d.year + "_" + d.teammateSurname + "_" + d.teammateName;
            })
            .rollup(function(d) {
                return {
                    selectedDriverWins: d3.sum(d, function(g) {
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition != "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition != "\\N" && g.teammatePosition == "\\N") {
                            return 1;
                        }
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition == "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition < g.teammatePosition) {
                            return 1;
                        }
                        return 0;
                    }),
                    teammateWins: d3.sum(d, function(g) {
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition != "\\N") {
                            return 1;
                        }
                        if (g.selectedDriverPosition != "\\N" && g.teammatePosition == "\\N") {
                            return 0;
                        }
                        if (g.selectedDriverPosition == "\\N" && g.teammatePosition == "\\N") {
                            return 1;
                        }
                        if (g.teammatePosition < g.selectedDriverPosition) {
                            return 1;
                        }
                        return 0;
                    }),
               }
            })
            .entries(newTuples);   
                
        /* DEBUG
        console.log(relevantData); */
        
        return relevantData;
    }
        
    drawTitle();
    </script>
    </body>
</html>